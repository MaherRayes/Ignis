<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SeeSharp</name>
    </assembly>
    <members>
        <member name="T:SeeSharp.Cameras.Camera">
            <summary>
            Base class for all camera models
            </summary>
        </member>
        <member name="P:SeeSharp.Cameras.Camera.Position">
            <summary>
            The position of the camera in world space (computed from the <see cref="P:SeeSharp.Cameras.Camera.WorldToCamera"/> matrix)
            </summary>
        </member>
        <member name="P:SeeSharp.Cameras.Camera.Direction">
            <summary>
            The principal view direction of the camera in world space (computed from the
            <see cref="P:SeeSharp.Cameras.Camera.WorldToCamera"/> matrix)
            </summary>
        </member>
        <member name="M:SeeSharp.Cameras.Camera.#ctor(System.Numerics.Matrix4x4)">
            <summary>Initializes the common camera parameters based on a world matrix</summary>
            <exception cref="T:System.ArgumentException">
                If the world to camera transform is not invertible.
            </exception>
        </member>
        <member name="P:SeeSharp.Cameras.Camera.WorldToCamera">
            <summary>
            Transformation from world space to camera space. Specifies position, view direction, and up vector.
            </summary>
        </member>
        <member name="M:SeeSharp.Cameras.Camera.UpdateResolution(System.Int32,System.Int32)">
            <summary>
            Updates camera parameters based on changed resolution in a frame buffer.
            </summary>
            <param name="width">The new width of the frame buffer in pixels</param>
            <param name="height">The new height of the frame buffer in pixels</param>
        </member>
        <member name="M:SeeSharp.Cameras.Camera.GenerateRay(System.Numerics.Vector2,SeeSharp.Sampling.RNG)">
            <summary>
            Samples a ray from the camera into the scene
            </summary>
            <param name="filmPos">Position on the image in pixel coordinates</param>
            <param name="rng">Random number generator</param>
            <returns>The sampled ray, pdf, and importance weight</returns>
        </member>
        <member name="M:SeeSharp.Cameras.Camera.SampleResponse(SeeSharp.Geometry.SurfacePoint,SeeSharp.Sampling.RNG)">
            <summary>
            Computes a Monte Carlo estimate of the contribution a scene point makes to the camera film
            </summary>
            <param name="scenePoint">A point on a surface, visible to the camera</param>
            <param name="rng">Random number generator</param>
            <returns>Importance estimate, sampled pixel coordinates, and pdf</returns>
        </member>
        <member name="M:SeeSharp.Cameras.Camera.SolidAngleToPixelJacobian(System.Numerics.Vector3)">
            <summary>
            Computes the change of area when mapping the hemisphere of directions around the camera onto
            pixels on the image.
            </summary>
            <param name="pos">A point in the scene that the camera is looking at</param>
            <returns>
                The jacobian. The factor by which the differential area on the image plane is larger than the
                differential solid angle corresponding to the given direction.
            </returns>
        </member>
        <member name="M:SeeSharp.Cameras.Camera.SurfaceAreaToSolidAngleJacobian(System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Computes the jacobian determinant for the mapping from surface area in the scene to solid angle
            about the camera
            </summary>
            <param name="point">A point in the scene that is visible to the camera</param>
            <param name="normal">Surface normal at the scene point</param>
            <returns>Jacobian determinant</returns>
        </member>
        <member name="F:SeeSharp.Cameras.Camera.worldToCamera">
            <summary>
            World space to camera space transform
            </summary>
        </member>
        <member name="F:SeeSharp.Cameras.Camera.cameraToWorld">
            <summary>
            Automatically computed inverse of <see cref="F:SeeSharp.Cameras.Camera.worldToCamera" />
            </summary>
        </member>
        <member name="T:SeeSharp.Cameras.CameraRaySample">
            <summary>
            Stores sample data for a ray generated by a camera
            </summary>
        </member>
        <member name="F:SeeSharp.Cameras.CameraRaySample.Ray">
            <summary>
            The sampled ray
            </summary>
        </member>
        <member name="F:SeeSharp.Cameras.CameraRaySample.Weight">
            <summary>
            The importance (= pixel contribution) divided by the sampling pdf
            </summary>
        </member>
        <member name="F:SeeSharp.Cameras.CameraRaySample.Point">
            <summary>
            Surface point on the camera lens, or the closest equivalent, depending on the camera model
            </summary>
        </member>
        <member name="F:SeeSharp.Cameras.CameraRaySample.PdfRay">
            <summary>
            Pdf that this ray was sampled with. Units depend on the camera model.
            </summary>
        </member>
        <member name="F:SeeSharp.Cameras.CameraRaySample.PdfConnect">
            <summary>
            Pdf of sampling the same point via connection in a light tracer.
            Same unit as <see cref="F:SeeSharp.Cameras.CameraRaySample.PdfRay" />.
            </summary>
        </member>
        <member name="T:SeeSharp.Cameras.CameraResponseSample">
            <summary>
            Stores the relevant data when sampling a connection to the camera
            </summary>
        </member>
        <member name="F:SeeSharp.Cameras.CameraResponseSample.Pixel">
            <summary>
            Pixel coordinates
            </summary>
        </member>
        <member name="F:SeeSharp.Cameras.CameraResponseSample.Position">
            <summary>
            Position of the lens point in world space, the sample only contributes if this position
            is visible from the scene point in question.
            </summary>
        </member>
        <member name="F:SeeSharp.Cameras.CameraResponseSample.Weight">
            <summary>
            Contribution to the sampled pixel ("importance" divided by the pdf)
            </summary>
        </member>
        <member name="F:SeeSharp.Cameras.CameraResponseSample.PdfConnect">
            <summary>
            Probability of sampling this connection
            </summary>
        </member>
        <member name="F:SeeSharp.Cameras.CameraResponseSample.PdfEmit">
            <summary>
            Probability of instead sampling a ray from the camera into the scene.
            Unit: surface area at primary hit point times [whatever happens on the specific camera model]
            </summary>
        </member>
        <member name="P:SeeSharp.Cameras.CameraResponseSample.IsValid">
            <summary>
            Checks whether this is a valid sample, i.e., non-zero and sampled with non-zero pdf
            </summary>
        </member>
        <member name="P:SeeSharp.Cameras.CameraResponseSample.Invalid">
            <summary>
            An invalid sample is one where everything is set to zero.
            </summary>
        </member>
        <member name="T:SeeSharp.Cameras.LightProbeCamera">
            <summary>
            Visualizes the illumination at a surface point in the scene in spherical coordinates.
            </summary>
        </member>
        <member name="M:SeeSharp.Cameras.LightProbeCamera.#ctor(System.Numerics.Vector3,System.Numerics.Vector3,System.Single,System.Numerics.Vector3)">
            <summary>
            Initializes a light probe camera at a surface point
            </summary>
            <param name="position">Point on a scene surface</param>
            <param name="normal">Surface normal at the query point, must point "outside" so it can be used
            to avoid self intersection problems with shadow rays</param>
            <param name="errorOffset">How far to move rays from the surface to avoid self-intersection</param>
            <param name="upVector">Defines the up direction of the probe in world space</param>
        </member>
        <member name="M:SeeSharp.Cameras.LightProbeCamera.GenerateRay(System.Numerics.Vector2,SeeSharp.Sampling.RNG)">
            <summary>
            Generates a ray from the camera into the scene.
            </summary>
            <param name="filmPos">Position (in pixels) on the image</param>
            <param name="rng">Unused, can be null</param>
            <returns>The chosen ray and associated weights</returns>
        </member>
        <member name="M:SeeSharp.Cameras.LightProbeCamera.SampleResponse(SeeSharp.Geometry.SurfacePoint,SeeSharp.Sampling.RNG)">
            <summary>
            Maps the point to the deterministic location on the image.
            </summary>
            <param name="scenePoint">A point on a scene surface</param>
            <param name="rng">Unused, can be null</param>
            <returns>Contribution, pixel, and sampling PDFs</returns>
        </member>
        <member name="M:SeeSharp.Cameras.LightProbeCamera.SolidAngleToPixelJacobian(System.Numerics.Vector3)">
            <summary>
            Computes the change of area when mapping a direction from the hemisphere around the camera
            to the image. Given by our transformation to spherical coordinates, followed by the scaling to the
            desired resolution.
            </summary>
            <param name="pos">Position in world space of a point towards which the direction points</param>
            <returns>
                Jacobian determinant that describes how much larger an area on the image plane is than
                the corresponding solid angle.
            </returns>
        </member>
        <member name="M:SeeSharp.Cameras.LightProbeCamera.UpdateResolution(System.Int32,System.Int32)">
            <summary>
            Updates the camera parameters after the frame buffer changed resolution.
            Must be called at least once, and with the correct values.
            </summary>
        </member>
        <member name="T:SeeSharp.Cameras.PerspectiveCamera">
            <summary>
            A simple pin-hole camera with thin-lens field-of-view (the latter is WIP and not yet supported).
            </summary>
        </member>
        <member name="P:SeeSharp.Cameras.PerspectiveCamera.Width">
            <summary>
            The width (in pixels) of the associated frame buffer
            </summary>
        </member>
        <member name="P:SeeSharp.Cameras.PerspectiveCamera.Height">
            <summary>
            The height (in pixels) of the associated frame buffer
            </summary>
        </member>
        <member name="P:SeeSharp.Cameras.PerspectiveCamera.VerticalFieldOfView">
            <summary>
            The vertical field of view this camera was created with (readonly) in degrees
            </summary>
        </member>
        <member name="M:SeeSharp.Cameras.PerspectiveCamera.#ctor(System.Numerics.Matrix4x4,System.Single,System.Single,System.Single)">
            <summary>
            Creates a new perspective camera.
            </summary>
            <param name="worldToCamera">
            Transformation from (right handed) world space to (right handed) camera space.
            The camera is centered at the origin, looking along negative Z. X is right, Y is up.
            </param>
            <param name="verticalFieldOfView">The full vertical opening angle in degrees.</param>
            <param name="lensRadius">Radius of the thin lens, determines the strength of depth-of-field</param>
            <param name="focalDistance">Distance from the camera where everything is in focus</param>
        </member>
        <member name="M:SeeSharp.Cameras.PerspectiveCamera.UpdateResolution(System.Int32,System.Int32)">
            <summary>
            Updates the camera parameters after the frame buffer changed resolution
            </summary>
        </member>
        <member name="M:SeeSharp.Cameras.PerspectiveCamera.GenerateRay(System.Numerics.Vector2,SeeSharp.Sampling.RNG)">
            <summary>
            Generates a ray from a position in the image into the scene
            </summary>
            <param name="filmPos">
                Position on the film plane: integer pixel coordinates and fractional position within
            </param>
            <param name="rng">
                Random number generator used to sample additional decisions (lens position for depth of field)
            </param>
            <returns>The sampled camera ray and related information like PDF and contribution</returns>
        </member>
        <member name="M:SeeSharp.Cameras.PerspectiveCamera.SampleResponse(SeeSharp.Geometry.SurfacePoint,SeeSharp.Sampling.RNG)">
            <summary>
            Samples a point on the camera lens that sees the given surface point. Returns an invalid
            sample if there is no such point.
            </summary>
            <param name="scenePoint">A point on a scene surface that might be seen by the camera</param>
            <param name="rng">RNG used to sample the lens. Can be null if the lens radius is zero.</param>
            <returns>The pixel coordinates and weights, or an invalid sample</returns>
        </member>
        <member name="M:SeeSharp.Cameras.PerspectiveCamera.SolidAngleToPixelJacobian(System.Numerics.Vector3)">
            <summary>
            Computes the change of area when mapping the hemisphere of directions around the camera onto
            pixels on the image.
            </summary>
            <param name="pos">A reference point in the scene that the camera is looking at</param>
            <returns>
                Factor by which the differential area on the image plane is larger than the differential solid
                angle corresponding to the given direction
            </returns>
        </member>
        <member name="T:SeeSharp.Common.Atomic">
            <summary>
            Provides utility functions for atomic operations.
            </summary>
        </member>
        <member name="M:SeeSharp.Common.Atomic.AddFloat(System.Single@,System.Single)">
            <summary>
            Adds two floating point values in an atomic fashion, using a compare-and-swap.
            Thread-safe version of: target += value;
            </summary>
            <param name="target">Destination</param>
            <param name="value">Value to add</param>
        </member>
        <member name="T:SeeSharp.Common.ConsoleWatchdog">
            <summary>
            A TextWriter that raises an event for each character written to the stream.
            Can be attached to the Console.Out to monitor output from all parts of the program.
            </summary>
        </member>
        <member name="T:SeeSharp.Common.Verbosity">
            <summary>
            Verbosity level to hide / show less important messages
            </summary>
        </member>
        <member name="F:SeeSharp.Common.Verbosity.Error">
            <summary>
            Error message, almost always means that rendering cannot continue (correctly)
            </summary>
        </member>
        <member name="F:SeeSharp.Common.Verbosity.Warning">
            <summary>
            A warning should be used if unexpected results can occur, but rendering can still proceed safely
            </summary>
        </member>
        <member name="F:SeeSharp.Common.Verbosity.Info">
            <summary>
            Info messages typically contain statistics, notice that an operation is done, ...
            </summary>
        </member>
        <member name="F:SeeSharp.Common.Verbosity.Debug">
            <summary>
            Highest verbosity level, used to output debug information
            </summary>
        </member>
        <member name="T:SeeSharp.Common.Logger">
            <summary>
            A simple command line logger that colors and tags messages based on their type. Verbosity can be
            set to control which types are displayed.
            </summary>
        </member>
        <member name="P:SeeSharp.Common.Logger.Verbosity">
            <summary>
            Minimum level of verbosity a message needs to have to be displayed. Default is
            <see cref="F:SeeSharp.Common.Verbosity.Info"/>.
            </summary>
        </member>
        <member name="M:SeeSharp.Common.Logger.Log(System.String,SeeSharp.Common.Verbosity)">
            <summary>
            Prints a log message with appropriate coloring if the verbosity level matches.
            </summary>
            <param name="message">The message to print</param>
            <param name="verbosity">The verbosity level of this message</param>
        </member>
        <member name="M:SeeSharp.Common.Logger.Error(System.String)">
            <summary>
            Calls <see cref="M:SeeSharp.Common.Logger.Log(System.String,SeeSharp.Common.Verbosity)"/> with verbosity level set to <see cref="F:SeeSharp.Common.Verbosity.Error"/>
            </summary>
        </member>
        <member name="M:SeeSharp.Common.Logger.Warning(System.String)">
            <summary>
            Calls <see cref="M:SeeSharp.Common.Logger.Log(System.String,SeeSharp.Common.Verbosity)"/> with verbosity level set to <see cref="F:SeeSharp.Common.Verbosity.Warning"/>
            </summary>
        </member>
        <member name="T:SeeSharp.Common.ProgressBar">
            <summary>
            A simple ASCII progress bar for the console. Estimates and displays the remaining time.
            Automatically detects if other parts of the application wrote to the console and makes sure not to
            overwrite anything. If the console does not support changing previous output (e.g., a file or the
            VS code debug console), the bar is written in a new line whenever it grew visibly (like from [#---]
            to [##--]).
            </summary>
        </member>
        <member name="M:SeeSharp.Common.ProgressBar.#ctor(System.Int32,System.Boolean,System.Boolean,System.String)">
            <summary>
            Initializes a new progress bar for a given amount of work. The amount of work should be specified
            as a number of (roughly) equally expensive steps.
            </summary>
            <param name="numBlocks">Number of blocks to display in the ASCII bar</param>
            <param name="displayWork">If true, displays the amount of total steps and the performed steps</param>
            <param name="displayTime">If true, displays the elapsed time and predicted total time</param>
            <param name="prefix">Text displayed in front of the progress bar</param>
        </member>
        <member name="M:SeeSharp.Common.ProgressBar.Start(System.Int32)">
            <summary>
            Notifies that the process has started.
            </summary>
            <param name="totalWork">Amount of steps that are performed in total (e.g., render iterations)</param>
        </member>
        <member name="M:SeeSharp.Common.ProgressBar.ReportDone(System.Int32)">
            <summary>
            Updates the progress bar after some work has been performed. Thread-safe.
            </summary>
            <param name="amount">How many steps have been performed</param>
        </member>
        <member name="T:SeeSharp.Common.SanityChecks">
            <summary>
            Provides common sanity checks like checking if a vector is normalized
            </summary>
        </member>
        <member name="M:SeeSharp.Common.SanityChecks.IsNormalized(System.Numerics.Vector3,System.Single)">
            <summary>
            Asserts that the given direction is normalized, i.e., has a length of one.
            </summary>
        </member>
        <member name="T:SeeSharp.Experiments.Benchmark">
            <summary>
            Conducts an experiment by rendering all images.
            </summary>
        </member>
        <member name="M:SeeSharp.Experiments.Benchmark.#ctor(SeeSharp.Experiments.Experiment,System.Collections.Generic.List{SeeSharp.Experiments.SceneConfig},System.String,System.Int32,System.Int32,SeeSharp.Image.FrameBuffer.Flags,System.Boolean)">
            <summary>
            Sets up a new benchmark that runs an experiment on different scenes
            </summary>
            <param name="experiment">The experiment (list of methods) to run</param>
            <param name="sceneConfigs">The scene configurations</param>
            <param name="workingDirectory">
                Directory to which the rendered images and other data will be written
            </param>
            <param name="width">Width of the rendered images in pixels</param>
            <param name="height">Height of the rendered images in pixels</param>
            <param name="frameBufferFlags">Flags for the frame buffer, e.g., to sync with tev</param>
            <param name="computeErrorMetrics">Compute error metrics when reference is available</param>
        </member>
        <member name="M:SeeSharp.Experiments.Benchmark.Run(System.String,System.Boolean)">
            <summary>
            Renders all scenes with all methods, generating one result directory per scene.
            If the reference images do not exist yet, they are also rendered. Each method's
            images are placed in a separate folder, using the method's name as the folder's name.
            </summary>
        </member>
        <member name="M:SeeSharp.Experiments.Benchmark.MakeFrameBuffer(System.String)">
            <summary>
            Creates a new frame buffer with the correct resolution
            </summary>
            <param name="filename">Desired file name</param>
        </member>
        <member name="F:SeeSharp.Experiments.Benchmark.width">
            <summary>
            Resolution of all images
            </summary>
        </member>
        <member name="F:SeeSharp.Experiments.Benchmark.height">
            <summary>
            Resolution of all images
            </summary>
        </member>
        <member name="F:SeeSharp.Experiments.Benchmark.experiment">
            <summary>
            The experiment to run on all scenes
            </summary>
        </member>
        <member name="T:SeeSharp.Experiments.Experiment">
            <summary>
            Describes an experiment with a list of named integrators.
            </summary>
        </member>
        <member name="T:SeeSharp.Experiments.Experiment.Method">
            <summary>
            A "method" is a named integrator with specific parameters
            </summary>
        </member>
        <member name="F:SeeSharp.Experiments.Experiment.Method.Name">
            <summary>
            Name of the method. Determines file and directory names.
            </summary>
        </member>
        <member name="F:SeeSharp.Experiments.Experiment.Method.Integrator">
            <summary>
            The integrator object to run.
            </summary>
        </member>
        <member name="M:SeeSharp.Experiments.Experiment.Method.#ctor(System.String,SeeSharp.Integrators.Integrator)">
            <summary>
            Creates a new method
            </summary>
            <param name="name">Name of the method. Determines file and directory names.</param>
            <param name="integrator">The integrator object to run, with the desired parameters set</param>
        </member>
        <member name="M:SeeSharp.Experiments.Experiment.MakeMethods">
            <summary>
            Factory function for the methods.
            </summary>
            <returns>A list of all methods that should be run in a benchmark</returns>
        </member>
        <member name="M:SeeSharp.Experiments.Experiment.OnStartScene(SeeSharp.Scene,System.String)">
            <summary>
            Called before the experiment is run on a test scene.
            </summary>
            <param name="scene">The scene that will be rendered</param>
            <param name="dir">Output directory</param>
        </member>
        <member name="M:SeeSharp.Experiments.Experiment.OnDoneScene(SeeSharp.Scene,System.String)">
            <summary>
            Called after all methods have been run on a test scene.
            </summary>
            <param name="scene">The scene that was rendered</param>
            <param name="dir">
            Output directory, each method is in a subdirectory; the method's name is the name of that subdirectory
            </param>
        </member>
        <member name="M:SeeSharp.Experiments.Experiment.OnStart(System.String)">
            <summary>
            Called before the experiment is run on a set of scenes
            </summary>
            <param name="workingDirectory">Output directory</param>
        </member>
        <member name="M:SeeSharp.Experiments.Experiment.OnDone(System.String)">
            <summary>
            Called after the experiment run has finished for all scenes
            </summary>
            <param name="workingDirectory">Output directory</param>
        </member>
        <member name="T:SeeSharp.Experiments.SceneConfig">
            <summary>
            Describes a scene configuration when running experiments
            </summary>
        </member>
        <member name="P:SeeSharp.Experiments.SceneConfig.Name">
            <summary>
            The name of the scene, used for the directory structure
            </summary>
        </member>
        <member name="P:SeeSharp.Experiments.SceneConfig.MaxDepth">
            <summary>
            Maximum path length used when rendering the scene. DI only = 2
            </summary>
        </member>
        <member name="P:SeeSharp.Experiments.SceneConfig.MinDepth">
            <summary>
            Minimum path length used when rendering the scene. No directly visible lights = 2
            </summary>
        </member>
        <member name="M:SeeSharp.Experiments.SceneConfig.MakeScene">
            <summary>
            Generates (or retrieves) the scene ready for rendering
            </summary>
            <returns>The generated scene</returns>
        </member>
        <member name="M:SeeSharp.Experiments.SceneConfig.GetReferenceImage(System.Int32,System.Int32)">
            <summary>
            Renders a reference image, or retrieves a cached one
            </summary>
            <param name="width">Width of the image</param>
            <param name="height">Height of the image</param>
            <returns>The reference image</returns>
        </member>
        <member name="T:SeeSharp.Experiments.SceneFromFile">
            <summary>
            Represents a scene loaded from a directory in the <see cref="T:SeeSharp.Experiments.SceneRegistry" />.
            </summary>
        </member>
        <member name="P:SeeSharp.Experiments.SceneFromFile.MaxDepth">
            <inheritdoc />
        </member>
        <member name="P:SeeSharp.Experiments.SceneFromFile.MinDepth">
            <inheritdoc />
        </member>
        <member name="P:SeeSharp.Experiments.SceneFromFile.Name">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Experiments.SceneFromFile.WithName(System.String)">
            <summary>
            Creates a shallow copy of this scene configuration under a new name.
            </summary>
            <param name="newName">The new name to use</param>
            <returns>Shallow copy with new name</returns>
        </member>
        <member name="M:SeeSharp.Experiments.SceneFromFile.GetReferenceImage(System.Int32,System.Int32)">
             <summary>
             Retrieves a cached reference image with the right resolution and maximum path length. If not
             available, a new reference is rendered and added to the cache.
            
             The reference cache is a directory called "References" next to the .json file that defines
             the scene.
             </summary>
             <param name="width">Width in pixels</param>
             <param name="height">Height in pixels</param>
             <returns>The reference image</returns>
        </member>
        <member name="M:SeeSharp.Experiments.SceneFromFile.#ctor(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Loads a new scene from file
            </summary>
            <param name="filename">Path to an existing scene's json file</param>
            <param name="minDepth">Minimum path length to use when rendering</param>
            <param name="maxDepth">Maximum path length to use when rendering</param>
            <param name="name">If a name different from the file basename is desired, specify it here.</param>
        </member>
        <member name="P:SeeSharp.Experiments.SceneFromFile.DefaultReferenceIntegrator">
            <summary>
            The default integrator used when rendering reference images, if no config.json file is present.
            </summary>
        </member>
        <member name="M:SeeSharp.Experiments.SceneFromFile.MakeScene">
            <summary>
            Creates a scene ready for rendering
            </summary>
            <returns>A shallow copy of the "blueprint" scene</returns>
        </member>
        <member name="T:SeeSharp.Experiments.SceneRegistry">
            <summary>
            Singleton that manages all available test scenes. Folders with test scenes can be registered as
            "sources" and will then be available everywhere.
            </summary>
        </member>
        <member name="M:SeeSharp.Experiments.SceneRegistry.AddSource(System.String)">
            <summary>
            Adds a directory to the list of sources. The contents must adhere the expected structure:
            Each subdirectory represents a scene, the name of the subdirectory is that of the scene.
            It should contain one or more .json files with the scene data, any meshes and textures, and
            (if available) pre-rendered reference images at various resolutions and maximum path lengths.
            </summary>
            <param name="directoryName">A full or relative path to an existing directory</param>
        </member>
        <member name="M:SeeSharp.Experiments.SceneRegistry.LoadScene(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Searches all sources for the given scene and returns the configuration retrieved from any one
            of the sources (not guaranteed to be a specific one in case of duplicates).
            </summary>
            <param name="name">The name of the scene. We look for a file "[source]/name/name.json</param>
            <param name="variant">If given, load the "name/variant/name-variant.json" file instead</param>
            <param name="maxDepth">If given, overrides the default maximum path length</param>
            <param name="minDepth">If given, overrides the default minimum path length</param>
            <returns>A <see cref="T:SeeSharp.Experiments.SceneFromFile"/> that represents the scene, if found, or null.</returns>
        </member>
        <member name="T:SeeSharp.Geometry.BoundingBox">
            <summary>
            Represents an axis aligned bounding box
            </summary>
        </member>
        <member name="F:SeeSharp.Geometry.BoundingBox.Min">
            <summary>
            Minimum and maximum values along all axes of the points within the box
            </summary>
        </member>
        <member name="F:SeeSharp.Geometry.BoundingBox.Max">
            <summary>
            Minimum and maximum values along all axes of the points within the box
            </summary>
        </member>
        <member name="M:SeeSharp.Geometry.BoundingBox.#ctor(System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Creates a new bounding box that spans the given region
            </summary>
        </member>
        <member name="P:SeeSharp.Geometry.BoundingBox.Empty">
            <summary>
            An empty box that contains nothing (max is smaller than min)
            </summary>
        </member>
        <member name="P:SeeSharp.Geometry.BoundingBox.Full">
            <summary>
            A box that spans the entire (representable) space
            </summary>
        </member>
        <member name="M:SeeSharp.Geometry.BoundingBox.GrowToContain(System.Numerics.Vector3)">
            <summary>
            Computes a new box with updated minimum and maximum so the given point is within the bounds.
            </summary>
            <param name="point">Point that should be within the box</param>
            <returns>A new box with the updated bounds</returns>
        </member>
        <member name="M:SeeSharp.Geometry.BoundingBox.GrowToContain(SeeSharp.Geometry.BoundingBox)">
            <summary>
            Computes a new box with updated minimum and maximum so the given box is entirely within the bounds.
            </summary>
            <param name="box">Other box that should be inside</param>
            <returns>A new box with the updated bounds</returns>
        </member>
        <member name="M:SeeSharp.Geometry.BoundingBox.IsInside(System.Numerics.Vector3)">
            <summary>
            Checks if a point is inside the bounding box
            </summary>
        </member>
        <member name="P:SeeSharp.Geometry.BoundingBox.Diagonal">
            <summary>
            Computes the diagonal vector of the box
            </summary>
        </member>
        <member name="T:SeeSharp.Geometry.Mesh">
            <summary>
            A simple triangle mesh with methods to uniformly sample its area.
            </summary>
        </member>
        <member name="F:SeeSharp.Geometry.Mesh.Material">
            <summary>
            The assigned material
            </summary>
        </member>
        <member name="M:SeeSharp.Geometry.Mesh.#ctor(System.Numerics.Vector3[],System.Int32[],System.Numerics.Vector3[],System.Numerics.Vector2[])">
            <summary>
            Creates a new mesh based on the given list of vertices, indices, and optional parameters
            </summary>
            <param name="vertices">List of vertices</param>
            <param name="indices">
                Three integers for each triangle that identify which vertices form that triangle
            </param>
            <param name="shadingNormals">Shading normals for each vertex</param>
            <param name="textureCoordinates">Texture coordinates for each vertex</param>
        </member>
        <member name="M:SeeSharp.Geometry.Mesh.Sample(System.Numerics.Vector2)">
            <summary>
            Samples a point uniformly distributed on the mesh surface
            </summary>
            <param name="primarySample">
                A primary sample space value that is projected onto the surface of the mesh.
            </param>
            <returns>A point and associated surface area pdf</returns>
        </member>
        <member name="M:SeeSharp.Geometry.Mesh.SampleInverse(SeeSharp.Geometry.SurfacePoint)">
            <summary>
            Performs the inverse of the projection done by <see cref="M:SeeSharp.Geometry.Mesh.Sample(System.Numerics.Vector2)"/>
            </summary>
            <param name="point">A point on the surface of this mesh</param>
            <returns>The primary sample space point that would have been projected there</returns>
        </member>
        <member name="M:SeeSharp.Geometry.Mesh.Pdf(SeeSharp.Geometry.SurfacePoint)">
            <returns>The surface area pdf of sampling the given point on the surface of this mesh.</returns>
        </member>
        <member name="T:SeeSharp.Geometry.MeshFactory">
            <summary>
            Provides utility functions to generate some simple meshes with basic shapes
            </summary>
        </member>
        <member name="M:SeeSharp.Geometry.MeshFactory.MakeCylinder(System.Numerics.Vector3,System.Numerics.Vector3,System.Single,System.Int32)">
            <summary>
            Creates a cylinder that connects two given points like a pipe
            </summary>
            <param name="from">The first point, the center of one cylinder disc</param>
            <param name="to">The second point, the center of the other cylinder disc</param>
            <param name="radius">Radius of the cylinder</param>
            <param name="numSegments">Number of quads used to build the outer surface</param>
        </member>
        <member name="M:SeeSharp.Geometry.MeshFactory.MakeCone(System.Numerics.Vector3,System.Numerics.Vector3,System.Single,System.Int32)">
            <summary>
            Creates a cone oriented such that it connects two points like an arrow tip
            </summary>
            <param name="baseCenter">The point in the center of the cone's base</param>
            <param name="tip">The position of the tip in world space</param>
            <param name="radius">Radius at the base of the cone</param>
            <param name="numSegments">Number of triangles used to build the side surface</param>
        </member>
        <member name="T:SeeSharp.Geometry.SurfacePoint">
            <summary>
            Represents a point on the surface of a mesh in the scene. Wrapper around <see cref="T:TinyEmbree.Hit"/> with
            additional SeeSharp specific material information.
            </summary>
        </member>
        <member name="P:SeeSharp.Geometry.SurfacePoint.Position">
            <summary>
            Position in world space
            </summary>
        </member>
        <member name="P:SeeSharp.Geometry.SurfacePoint.Normal">
            <summary>
            Face normal at the point (i.e., actual geometric normal, not the shading normal)
            </summary>
        </member>
        <member name="P:SeeSharp.Geometry.SurfacePoint.BarycentricCoords">
            <summary>
            Barycentric coordinates within the primitive
            </summary>
        </member>
        <member name="P:SeeSharp.Geometry.SurfacePoint.Mesh">
            <summary>
            The mesh on which this point lies
            </summary>
        </member>
        <member name="P:SeeSharp.Geometry.SurfacePoint.PrimId">
            <summary>
            Index of the primitive within the mesh
            </summary>
        </member>
        <member name="P:SeeSharp.Geometry.SurfacePoint.ErrorOffset">
            <summary>
            Offset that should be used to avoid self-intersection during ray tracing
            </summary>
        </member>
        <member name="P:SeeSharp.Geometry.SurfacePoint.Distance">
            <summary>
            Distance from a previous point if this is a ray intersection
            </summary>
        </member>
        <member name="M:SeeSharp.Geometry.SurfacePoint.op_Implicit(SeeSharp.Geometry.SurfacePoint)~System.Boolean">
            <summary>
            Checks if the point is valid
            </summary>
        </member>
        <member name="M:SeeSharp.Geometry.SurfacePoint.op_Implicit(SeeSharp.Geometry.SurfacePoint)~TinyEmbree.Hit">
            <summary>
            Implicit cast to a TinyEmbree hit object for convenience
            </summary>
        </member>
        <member name="M:SeeSharp.Geometry.SurfacePoint.op_Implicit(TinyEmbree.Hit)~SeeSharp.Geometry.SurfacePoint">
            <summary>
            Implicit cast from a TinyEmbree hit object for convenience
            </summary>
            <param name="hit"></param>
        </member>
        <member name="P:SeeSharp.Geometry.SurfacePoint.ShadingNormal">
            <summary>
            Computes the shading normal on the fly, can be expensive
            </summary>
        </member>
        <member name="P:SeeSharp.Geometry.SurfacePoint.TextureCoordinates">
            <summary>
            Computes / looks up the texture coordinates on-the-fly
            </summary>
        </member>
        <member name="P:SeeSharp.Geometry.SurfacePoint.Material">
            <summary>
            The material of the intersected mesh
            </summary>
        </member>
        <member name="T:SeeSharp.Geometry.SurfaceSample">
            <summary>
            A point on a surface that was sampled randomly
            </summary>
        </member>
        <member name="F:SeeSharp.Geometry.SurfaceSample.Point">
            <summary>
            The sampled point
            </summary>
        </member>
        <member name="F:SeeSharp.Geometry.SurfaceSample.Pdf">
            <summary>
            Probability density at this point, per surface area
            </summary>
        </member>
        <member name="T:SeeSharp.Image.FrameBuffer">
            <summary>
            Provides an image buffer to receive pixel estimates during rendering. Additional named layers can
            be attached to store AOVs. If tev sync is used, this needs to be disposed of correctly, e.g., via
            a "using" block.
            </summary>
        </member>
        <member name="F:SeeSharp.Image.FrameBuffer.Width">
            <summary>
            Width of the frame buffer in pixels
            </summary>
        </member>
        <member name="F:SeeSharp.Image.FrameBuffer.Height">
            <summary>
            Height of the frame buffer in pixels
            </summary>
        </member>
        <member name="P:SeeSharp.Image.FrameBuffer.Image">
            <summary>
            The (current) rendered image. Only normalized correctly after <see cref="M:SeeSharp.Image.FrameBuffer.EndIteration"/>
            </summary>
        </member>
        <member name="F:SeeSharp.Image.FrameBuffer.ReferenceImage">
            <summary>
            The reference image. If set, error metrics will be calculated for each iteration
            </summary>
        </member>
        <member name="F:SeeSharp.Image.FrameBuffer.PixelVariance">
            <summary>
            Automatically added layer that estimates per-pixel variances in the frame buffer
            </summary>
        </member>
        <member name="F:SeeSharp.Image.FrameBuffer.MetaData">
            <summary>
            Associated meta data that will be stored along with the final rendered image. By default,
            contains an item "RenderTime" which tracks the total time in milliseconds over all iterations,
            and "NumIterations".
            </summary>
        </member>
        <member name="M:SeeSharp.Image.FrameBuffer.AddLayer(System.String,SeeSharp.Image.Layer)">
            <summary>
            Adds a new layer to the frame buffer. Will be written with the final image, either as a layer or
            separately, depending on the file format.
            </summary>
        </member>
        <member name="M:SeeSharp.Image.FrameBuffer.GetLayer(System.String)">
            <returns>Layer with the given name</returns>
        </member>
        <member name="P:SeeSharp.Image.FrameBuffer.CurIteration">
            <summary>
            1-based index of the current iteration (i.e., the total number of iterations so far).
            If rendering has not started yet, this will be zero.
            </summary>
        </member>
        <member name="P:SeeSharp.Image.FrameBuffer.Basename">
            <summary>
            The full path to the final rendered image file, but without the extension. Can be used to
            generate adequate names for auxiliary files and debug data.
            </summary>
        </member>
        <member name="P:SeeSharp.Image.FrameBuffer.Extension">
            <summary>
            File extension of the final image, which also specifies the format.
            </summary>
        </member>
        <member name="T:SeeSharp.Image.FrameBuffer.Flags">
            <summary>
            Flags controlling some behaviour of the buffer
            </summary>
        </member>
        <member name="F:SeeSharp.Image.FrameBuffer.Flags.None">
            <summary> Use default behaviour </summary>
        </member>
        <member name="F:SeeSharp.Image.FrameBuffer.Flags.WriteIntermediate">
            <summary> Write the result of each iteration into a distinct file </summary>
        </member>
        <member name="F:SeeSharp.Image.FrameBuffer.Flags.WriteContinously">
            <summary> Continously update the rendering result after each iteration </summary>
        </member>
        <member name="F:SeeSharp.Image.FrameBuffer.Flags.SendToTev">
            <summary> Like WriteContinously, but sends the data via a socket to the tev viewer </summary>
        </member>
        <member name="M:SeeSharp.Image.FrameBuffer.#ctor(System.Int32,System.Int32,System.String,SeeSharp.Image.FrameBuffer.Flags)">
            <param name="width">Width in pixels</param>
            <param name="height">Height in pixels</param>
            <param name="filename">
                Filename to use when writing the final rendering. Can be null if <see cref="M:SeeSharp.Image.FrameBuffer.WriteToFile(System.String)"/> is
                never called without an explicit filename and no flags are set.
            </param>
            <param name="flags">Controls how incremental results are stored</param>
        </member>
        <member name="M:SeeSharp.Image.FrameBuffer.Splat(System.Single,System.Single,SimpleImageIO.RgbColor)">
            <summary>
            Adds a contribution to the frame buffer
            </summary>
            <param name="x">Horizontal pixel coordinate, [0, Width), left to right</param>
            <param name="y">Vertical pixel coordinate, [0, Height), top to bottom</param>
            <param name="value">Color to add to the current value</param>
        </member>
        <member name="M:SeeSharp.Image.FrameBuffer.Initialize">
            <summary>
            Initializes the memory for the image data and aux layers. Should be called exactly once before / at
            the start of the first rendering iteration.
            </summary>
        </member>
        <member name="M:SeeSharp.Image.FrameBuffer.StartIteration">
            <summary>
            Should be called before the start of each new rendering iteration. A rendering iteration is one of
            multiple equal-sized batches of samples per pixel.
            </summary>
        </member>
        <member name="P:SeeSharp.Image.FrameBuffer.RenderTimeMs">
            <summary>
            Current total time spent between <see cref="M:SeeSharp.Image.FrameBuffer.StartIteration"/> and <see cref="M:SeeSharp.Image.FrameBuffer.EndIteration"/>,
            i.e, the render time without frame buffer overhead.
            </summary>
        </member>
        <member name="M:SeeSharp.Image.FrameBuffer.EndIteration">
            <summary>
            Notifies that the rendering iteration is finished, intermediate results can be written, and time
            measurments can be stopped.
            </summary>
        </member>
        <member name="M:SeeSharp.Image.FrameBuffer.Reset">
            <summary>
            Clears the image and all layers and resets the rendering time to zero
            </summary>
        </member>
        <member name="M:SeeSharp.Image.FrameBuffer.Clear">
            <summary>
            Clears the image and all layers, but keeps the rendering time
            </summary>
        </member>
        <member name="M:SeeSharp.Image.FrameBuffer.WriteToFile(System.String)">
            <summary>
            Writes the current rendered image to a file on disk.
            </summary>
            <param name="fname">The desired file name. If not given, uses the final image name.</param>
        </member>
        <member name="M:SeeSharp.Image.FrameBuffer.Dispose">
            <summary>
            Closes the tev TCP connection, if it was set up.
            </summary>
        </member>
        <member name="T:SeeSharp.Image.ImageTexture">
            <summary>
            An image texture
            </summary>
        </member>
        <member name="T:SeeSharp.Image.ImageTexture.BorderHandling">
            <summary>
            How texture coordinates outside the [0,1] range are mapped to pixels in the image
            </summary>
        </member>
        <member name="F:SeeSharp.Image.ImageTexture.BorderHandling.Repeat">
            <summary>
            Repeat the image in all directions, 1.1 is mapped to 0.1
            </summary>
        </member>
        <member name="F:SeeSharp.Image.ImageTexture.BorderHandling.Clamp">
            <summary>
            Maps coordinates outside the image to the closest pixel that is within the image
            </summary>
        </member>
        <member name="F:SeeSharp.Image.ImageTexture.Border">
            <summary>
            The border handling mode to be used, defaults to "Repeat"
            </summary>
        </member>
        <member name="M:SeeSharp.Image.ImageTexture.ComputeTexel(System.Numerics.Vector2)">
            <returns> The (x,y) / (col,row) coordinate of the texel. </returns>
        </member>
        <member name="F:SeeSharp.Image.ImageTexture.Image">
            <summary>
            The texture image
            </summary>
        </member>
        <member name="T:SeeSharp.Image.Layer">
            <summary>
            A layer in the frame buffer, an image to hold AOVs
            </summary>
        </member>
        <member name="P:SeeSharp.Image.Layer.Image">
            <summary>
            The image buffer
            </summary>
        </member>
        <member name="M:SeeSharp.Image.Layer.Freeze">
            <summary>
            Stops normalizing the image data. Useful if an AOV is only written during some initial iterations.
            </summary>
        </member>
        <member name="M:SeeSharp.Image.Layer.Init(System.Int32,System.Int32)">
            <summary>
            Called once before the first rendering iteration
            </summary>
            <param name="width">The width of the frame buffer</param>
            <param name="height">The height of the frame buffer</param>
        </member>
        <member name="M:SeeSharp.Image.Layer.OnStartIteration(System.Int32)">
            <summary>
            Called at the beginning of each new rendering iteration. Derived classes should always call
            this function to achieve proper normalization
            </summary>
            <param name="curIteration">The 1-based index of the iteration that starts now</param>
        </member>
        <member name="M:SeeSharp.Image.Layer.OnEndIteration(System.Int32)">
            <summary>
            Called at the end of each rendering iteration
            </summary>
            <param name="curIteration">The 1-based index of the iteration that just finished</param>
        </member>
        <member name="F:SeeSharp.Image.Layer.curIteration">
            <summary>
            The 1-based index of the iteration that is currently being rendered
            </summary>
        </member>
        <member name="T:SeeSharp.Image.MonoLayer">
            <summary>
            Convenience layer for images storing monochromatic values
            </summary>
        </member>
        <member name="M:SeeSharp.Image.MonoLayer.Init(System.Int32,System.Int32)">
            <summary>
            Called once before the first rendering iteration
            </summary>
            <param name="width">The width of the frame buffer</param>
            <param name="height">The height of the frame buffer</param>
        </member>
        <member name="M:SeeSharp.Image.MonoLayer.Splat(System.Single,System.Single,System.Single)">
            <summary>
            Adds a new sample contribution to the layer
            </summary>
        </member>
        <member name="T:SeeSharp.Image.RgbLayer">
            <summary>
            Convenience layer for images storing RGB values
            </summary>
        </member>
        <member name="M:SeeSharp.Image.RgbLayer.Init(System.Int32,System.Int32)">
            <summary>
            Called once before the first rendering iteration
            </summary>
            <param name="width">The width of the frame buffer</param>
            <param name="height">The height of the frame buffer</param>
        </member>
        <member name="M:SeeSharp.Image.RgbLayer.Splat(System.Single,System.Single,SimpleImageIO.RgbColor)">
            <summary>
            Adds a new sample contribution to the layer
            </summary>
        </member>
        <member name="T:SeeSharp.Image.TextureMono">
            <summary>
            Monochromatic image texture
            </summary>
        </member>
        <member name="M:SeeSharp.Image.TextureMono.#ctor(System.Single)">
            <summary>
            Creates a single pixel texture set to a constant value
            </summary>
        </member>
        <member name="M:SeeSharp.Image.TextureMono.#ctor(SimpleImageIO.MonochromeImage)">
            <summary>
            Creates a texture from a monochromatic image
            </summary>
        </member>
        <member name="P:SeeSharp.Image.TextureMono.IsConstant">
            <summary>
            True if the texture is just a single constant value
            </summary>
        </member>
        <member name="M:SeeSharp.Image.TextureMono.Lookup(System.Numerics.Vector2)">
            <returns>The texture value for the given uv-coordinates.</returns>
        </member>
        <member name="T:SeeSharp.Image.TextureRgb">
            <summary>
            An RGB image texture
            </summary>
        </member>
        <member name="M:SeeSharp.Image.TextureRgb.#ctor(SimpleImageIO.RgbColor)">
            <summary>
            Creates a single-pixel image texture with a constant color
            </summary>
        </member>
        <member name="M:SeeSharp.Image.TextureRgb.#ctor(System.String)">
            <summary>
            Creates a texture from an RGB image
            </summary>
            <param name="filename">Full path to the RGB image</param>
        </member>
        <member name="P:SeeSharp.Image.TextureRgb.IsConstant">
            <summary>
            True if the texture is just a single constant value
            </summary>
        </member>
        <member name="M:SeeSharp.Image.TextureRgb.Lookup(System.Numerics.Vector2)">
            <returns>Color value at the given uv-coordinates</returns>
        </member>
        <member name="T:SeeSharp.Image.VarianceLayer">
            <summary>
            Estimates the pixel variance in the rendered image.
            "Pixel variance" is defined as the squared deviation of the pixel value from each iteration
            from the mean pixel value across all iterations.
            Note that this does not necessarily equal the variance of the underlying Monte Carlo estimator,
            especially not if MIS is used. It is a lower-bound approximation of that.
            </summary>
        </member>
        <member name="F:SeeSharp.Image.VarianceLayer.Average">
            <summary>
            Average variance over the entire image
            </summary>
        </member>
        <member name="M:SeeSharp.Image.VarianceLayer.Init(System.Int32,System.Int32)">
            <summary>
            Called once before the first rendering iteration
            </summary>
            <param name="width">The width of the frame buffer</param>
            <param name="height">The height of the frame buffer</param>
        </member>
        <member name="M:SeeSharp.Image.VarianceLayer.Splat(System.Single,System.Single,SimpleImageIO.RgbColor)">
            <summary>
            Splats a new pixel value to the current pixel value buffer
            </summary>
        </member>
        <member name="M:SeeSharp.Image.VarianceLayer.OnStartIteration(System.Int32)">
            <summary>
            Normalizes and clears the internal buffers
            </summary>
        </member>
        <member name="M:SeeSharp.Image.VarianceLayer.OnEndIteration(System.Int32)">
            <summary>
            Computes the pixel variances and their average
            </summary>
        </member>
        <member name="T:SeeSharp.Integrators.Bidir.BidirBase">
            <summary>
            Basis for many bidirectional algorithms. Splits rendering into multiple iterations. Each iteration
            traces a certain number of paths from the light sources and one camera path per pixel.
            Derived classes can control the sampling decisions and techniques.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.NumIterations">
            <summary>
            Number of iterations (batches of one sample per pixel) to render
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.MaximumRenderTimeMs">
            <summary>
            The maximum time in milliseconds that should be spent rendering.
            Excludes framebuffer overhead and other operations that are not part of the core rendering logic.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.NumLightPaths">
            <summary>
            Number of light paths per iteration. If not given, traces one per pixel.
            Must only be changed in-between rendering iterations. Otherwise: mayhem.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.BaseSeedCamera">
            <summary>
            The base seed to generate camera paths.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.BaseSeedLight">
            <summary>
            The base seed used when sampling paths from the light sources
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.PathLogger">
            <summary>
            Can be set to log some or all paths that have been sampled. Full support is still WIP.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.Scene">
            <summary>
            The scene that is currently being rendered
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.LightPaths">
            <summary>
            The current batch of light paths traced during the current iteration
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.EnableDenoiser">
            <summary>
            If set to true (default) runs Intel Open Image Denoise after the end of the last rendering iteration
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.DenoiseBuffers">
            <summary>
            Logs denoiser-related features at the primary hit points of all camera paths
            </summary>
        </member>
        <member name="T:SeeSharp.Integrators.Bidir.BidirBase.PathPdfPair">
            <summary>
            Forward and backward sampling probabilities of a path edge
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.PathPdfPair.PdfFromAncestor">
            <summary>
            PDF of sampling this vertex when coming from its actual ancestor
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.PathPdfPair.PdfToAncestor">
            <summary>
            PDF of sampling the ancestor of this vertex, if we were sampling the other way around
            </summary>
        </member>
        <member name="T:SeeSharp.Integrators.Bidir.BidirBase.CameraPath">
            <summary>
            Tracks the state of a camera path
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.CameraPath.Pixel">
            <summary>
            The pixel position where the path was started.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.CameraPath.Throughput">
            <summary>
            The product of the local estimators along the path (BSDF * cos / pdf)
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.CameraPath.Vertices">
            <summary>
            The pdf values for sampling this path.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.CameraPath.Distances">
            <summary>
            Distances between all points sampled along this path
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.CameraPath.MaximumPriorRoughness">
            <summary>
            Maximum roughness of any surface material encountered along the path, prior to the currently
            last vertex.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.BidirBase.CameraPath.CurrentRoughness">
            <summary>
            Roughness of the material at the currently last vertex of the path.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.ProcessPathCache">
            <summary>
            Called once per iteration after the light paths have been traced.
            Use this to create acceleration structures etc.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.SelectLight(SeeSharp.Geometry.SurfacePoint@,SeeSharp.Sampling.RNG)">
            <summary>
            Used by next event estimation to select a light source
            </summary>
            <param name="from">A point on a surface where next event is performed</param>
            <param name="rng">Random number generator</param>
            <returns>The selected light and the discrete probability of selecting that light</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.SelectLightPmf(SeeSharp.Geometry.SurfacePoint@,SeeSharp.Shading.Emitters.Emitter)">
            <returns>
            The discrete probability of selecting the given light when performing next event at the given
            shading point.
            </returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.EstimatePixelValue(SeeSharp.Geometry.SurfacePoint@,System.Numerics.Vector2,TinyEmbree.Ray@,System.Single,SimpleImageIO.RgbColor,SeeSharp.Sampling.RNG)">
            <summary>
            Called once for each pixel per iteration. Expected to perform some sort of path tracing,
            possibly connecting vertices with those from the light path cache.
            </summary>
            <returns>The estimated pixel value.</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.OnEndIteration(System.UInt32)">
            <summary>
            Called once after the end of each rendering iteration (one sample per pixel)
            </summary>
            <param name="iteration">The 0-based index of the iteration that just finished</param>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.OnStartIteration(System.UInt32)">
            <summary>
            Called once before the start of each rendering iteration (one sample per pixel)
            </summary>
            <param name="iteration">The 0-based index of the iteration that will now start</param>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.OnAfterRender">
            <summary>
            Called after all rendering iterations are finished, or the time budget has been exhausted
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.OnBeforeRender">
            <summary>
            Called just before the main render loop starts. Not counted towards the render time. Use this to
            initialize auxiliary buffers for debugging purposes.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.MakeLightPathCache">
            <summary>
            Generates the light path cache used to sample and store light paths.
            Called at the beginning of the rendering process before the first iteration.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.Render(SeeSharp.Scene)">
            <summary>
            Renders the scene with the current settings. Not thread-safe: Only one scene can be rendered at a
            time by the same object of this class.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.RegisterSample(SimpleImageIO.RgbColor,System.Single,System.Numerics.Vector2,System.Int32,System.Int32,System.Int32)">
            <summary>
            Called for each sample that has a non-zero contribution to the image.
            This can be used to write out pyramids of sampling technique images / MIS weights.
            The default implementation does nothing.
            </summary>
            <param name="weight">The sample contribution not yet weighted by MIS</param>
            <param name="misWeight">The MIS weight that will be multiplied on the sample weight</param>
            <param name="pixel">The pixel to which this sample contributes</param>
            <param name="cameraPathLength">Number of edges in the camera sub-path (0 if light tracer).</param>
            <param name="lightPathLength">Number of edges in the light sub-path (0 when hitting the light).</param>
            <param name="fullLength">Number of edges forming the full path. Used to disambiguate techniques.</param>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.OnLightTracerSample(SimpleImageIO.RgbColor,System.Single,System.Numerics.Vector2,SeeSharp.Integrators.Common.PathVertex,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Called for each sample generated by the light tracer.
            </summary>
            <param name="weight">The sample contribution not yet weighted by MIS</param>
            <param name="misWeight">The MIS weight that will be multiplied on the sample weight</param>
            <param name="pixel">The pixel to which this sample contributes</param>
            <param name="lightVertex">The last vertex on the light path</param>
            <param name="pdfCamToPrimary">
            Surface area pdf of sampling the last light path vertex when starting from the camera
            </param>
            <param name="pdfReverse">
            Surface area pdf of sampling the ancestor of the last light path vertex, when starting from the
            camera.
            </param>
            <param name="pdfNextEvent">
            Surface area pdf of sampling the ancestor of the last light path vertex via next event estimation.
            Will be zero unless this is a direct illumination sample.
            </param>
            <param name="distToCam">Distance of the last vertex to the camera</param>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.OnNextEventSample(SimpleImageIO.RgbColor,System.Single,SeeSharp.Integrators.Bidir.BidirBase.CameraPath,System.Single,System.Single,System.Single,System.Single,SeeSharp.Shading.Emitters.Emitter,System.Numerics.Vector3,SeeSharp.Geometry.SurfacePoint)">
            <summary>
            Called for each full path sample generated via next event estimation on a camera path.
            </summary>
            <param name="weight">The sample contribution not yet weighted by MIS</param>
            <param name="misWeight">The MIS weight that will be multiplied on the sample weight</param>
            <param name="cameraPath">The camera path until the point where NEE was performed</param>
            <param name="pdfEmit">
            Surface area pdf of sampling the last camera vertex when starting at the light source.
            This also includes the pdf of sampling the point on the light during emission.
            </param>
            <param name="pdfNextEvent">Surface area pdf used for next event estimation</param>
            <param name="pdfHit">
            Surface area pdf of sampling the same light source point by continuing the path
            </param>
            <param name="pdfReverse">
            Surface area pdf of sampling the ancestor of the last camera vertex, when starting at the light
            source.
            </param>
            <param name="emitter">The emitter that was connected to</param>
            <param name="lightToSurface">
            Direction from the point on the light to the last camera vertex.
            </param>
            <param name="lightPoint">The point on the light</param>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.OnEmitterHitSample(SimpleImageIO.RgbColor,System.Single,SeeSharp.Integrators.Bidir.BidirBase.CameraPath,System.Single,System.Single,SeeSharp.Shading.Emitters.Emitter,System.Numerics.Vector3,SeeSharp.Geometry.SurfacePoint)">
            <summary>
            Called for each full path sample generated by hitting a light source during the random walk from
            the camera.
            </summary>
            <param name="weight">The sample contribution not yet weighted by MIS</param>
            <param name="misWeight">The MIS weight that will be multiplied on the sample weight</param>
            <param name="cameraPath">The camera path until the point where NEE was performed</param>
            <param name="pdfEmit">
            Surface area pdf of sampling the last camera vertex when starting at the light source.
            This also includes the pdf of sampling the point on the light during emission.
            </param>
            <param name="pdfNextEvent">
            Surface area pdf of sampling the same light source point via next event estimation instead.
            </param>
            <param name="emitter">The emitter that was hit</param>
            <param name="lightToSurface">
            Direction from the point on the light to the last camera vertex.
            </param>
            <param name="lightPoint">The point on the light</param>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.OnBidirConnectSample(SimpleImageIO.RgbColor,System.Single,SeeSharp.Integrators.Bidir.BidirBase.CameraPath,SeeSharp.Integrators.Common.PathVertex,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Called for each full path generated by connecting a camera sub-path and a light sub-path
            via a shadow ray.
            </summary>
            <param name="weight">The sample contribution not yet weighted by MIS</param>
            <param name="misWeight">The MIS weight that will be multiplied on the sample weight</param>
            <param name="cameraPath">The camera path until the point where NEE was performed</param>
            <param name="lightVertex">Last vertex of the camera sub-path that was connected to</param>
            <param name="pdfCameraReverse">
            Surface area pdf of sampling the ancestor of the last camera vertex when continuing the light
            sub-path instead
            </param>
            <param name="pdfCameraToLight">
            Surface area pdf of sampling the connecting edge by continuing the camera path instead
            </param>
            <param name="pdfLightReverse">
            Surface area pdf of sampling the ancestor of the last light vertex when continuing the camera
            sub-path instead
            </param>
            <param name="pdfLightToCamera">
            Surface area pdf of sampling the connecting edge by continuing the light path instead
            </param>
            <param name="pdfNextEvent">
            Zero if the light sub-path has more than one edge. Otherwise, the surface area pdf of sampling
            that edge via next event estimation from the camera instead
            </param>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.LightTracerMis(SeeSharp.Integrators.Common.PathVertex,System.Single,System.Single,System.Single,System.Numerics.Vector2,System.Single)">
            <summary>
            Computes the MIS weight of a light tracer sample, for example via the balance heuristic.
            </summary>
            <param name="lightVertex">The last vertex of the light sub-path</param>
            <param name="pdfCamToPrimary">
            Surface area pdf of sampling the last light path vertex when starting from the camera
            </param>
            <param name="pdfReverse">
            Surface area pdf of sampling the ancestor of the last light path vertex, when starting from the
            camera.
            </param>
            <param name="pdfNextEvent">
            Surface area pdf of sampling the ancestor of the last light path vertex via next event estimation.
            Will be zero unless this is a direct illumination sample.
            </param>
            <param name="pixel">The pixel on the image the path contributes to</param>
            <param name="distToCam">Distance between the camera and the last light path vertex</param>
            <returns>MIS weight of the sampled path</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.SplatLightVertices">
            <summary>
            Connects all vertices along all light paths to the camera via shadow rays ("light tracing").
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.ConnectLightPathToCamera(System.Int32)">
            <summary>
            Connects the vertices of the i-th path to the camera ("light tracing")
            </summary>
            <param name="pathIdx">Index of the path in the cache</param>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.BidirConnectMis(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,SeeSharp.Integrators.Common.PathVertex,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Computes the MIS weight of a bidirectional connection.
            </summary>
            <param name="cameraPath">The camera path that was connected to a light vertex</param>
            <param name="lightVertex">The light vertex that was connected to</param>
            <param name="pdfCameraReverse">
            Surface area pdf of sampling the previous vertex along the camera path when coming from the light.
            </param>
            <param name="pdfCameraToLight">
            Surface area pdf of sampling the light vertex by continuing the camera path instead.
            </param>
            <param name="pdfLightReverse">
            Surface area pdf of sampling the previous vertex along the light path when coming from the camera
            </param>
            <param name="pdfLightToCamera">
            Surface area pdf of sampling the last camera vertex by continuing the light path instead
            </param>
            <param name="pdfNextEvent">
            If the light path consists of a single edge, this is the surface area pdf of sampling the same
            edge via next event estimation at the last light path vertex. Otherwise zero.
            </param>
            <returns>MIS weight for the connection</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.SelectBidirPath(SeeSharp.Geometry.SurfacePoint,System.Numerics.Vector3,System.Numerics.Vector2,SeeSharp.Sampling.RNG)">
            <summary>
            Called to importance sample a light path vertex to connect to. Can either select an entire light
            path, or an individual vertex. By default yields a deterministic mapping of each camera path to
            all vertices of a light path, like classic bidirectional path tracing.
            </summary>
            <param name="cameraPoint">The camera vertex where a connection is to be made</param>
            <param name="outDir">Direction from the camera vertex towards its ancestor</param>
            <param name="pixel">The pixel that the camera path originated in</param>
            <param name="rng">Random number generator for sampling a vertex</param>
            <returns>
            Index of the selected light path, index of the vertex within or -1 for all, and the probability
            of sampling that vertex.
            </returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.BidirConnections(SeeSharp.Geometry.SurfacePoint,System.Numerics.Vector3,SeeSharp.Sampling.RNG,SeeSharp.Integrators.Bidir.BidirBase.CameraPath,System.Single)">
            <summary>
            Computes the contribution of inner path connections at the given camera path vertex
            </summary>
            <param name="cameraPoint">The last vertex of the camera path</param>
            <param name="outDir">Direction from the camera vertex towards its ancestor</param>
            <param name="rng">Random number generator</param>
            <param name="path">The camera path</param>
            <param name="reversePdfJacobian">
            Jacobian to convert a solid angle density at the camera vertex to a surface area density at its
            ancestor vertex.
            </param>
            <returns>The sum of all MIS weighted contributions for inner path connections</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.NextEventMis(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Computes the MIS weight for next event estimation along a camera path
            </summary>
            <param name="cameraPath">The camera path</param>
            <param name="pdfEmit">
            Product surface area density of sampling the next event edge (vertex on the light and last camera
            path vertex) when emitting a light path.
            </param>
            <param name="pdfNextEvent">Surface area pdf of sampling the light vertex via next event</param>
            <param name="pdfHit">
            Surface area pdf of sampling the light vertex by continuing the camera path instead
            </param>
            <param name="pdfReverse">
            Surface area pdf of sampling the second-to-last camera path vertex when tracing a light path
            </param>
            <returns>MIS weight</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.SampleNextEvent(SeeSharp.Geometry.SurfacePoint,SeeSharp.Sampling.RNG)">
            <summary>
            Samples an emitter and a point on its surface for next event estimation
            </summary>
            <param name="from">The shading point</param>
            <param name="rng">Random number generator</param>
            <returns>The sampled emitter and point on the emitter</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.NextEventPdf(SeeSharp.Geometry.SurfacePoint,SeeSharp.Geometry.SurfacePoint)">
            <summary>
            Computes the pdf used by <see cref="M:SeeSharp.Integrators.Bidir.BidirBase.SampleNextEvent(SeeSharp.Geometry.SurfacePoint,SeeSharp.Sampling.RNG)" />
            </summary>
            <param name="from">The shading point</param>
            <param name="to">The point on the light source</param>
            <returns>PDF of next event estimation</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.ComputeNextEventBackgroundProbability">
            <summary>
            The probability of selecting the background for next event estimation, instead of an emissive
            surface.
            </summary>
            <returns>The background selection probability, by default uniform</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.PerformNextEventEstimation(TinyEmbree.Ray,SeeSharp.Geometry.SurfacePoint,SeeSharp.Sampling.RNG,SeeSharp.Integrators.Bidir.BidirBase.CameraPath,System.Single)">
            <summary>
            Performs next event estimation at the end point of a camera path
            </summary>
            <param name="ray">The last ray that was traced</param>
            <param name="hit">The hit point of that ray, i.e., the position where NEE should be done</param>
            <param name="rng">Random number generator</param>
            <param name="path">The camera path</param>
            <param name="reversePdfJacobian">
            Jacobian to convert the reverse sampling pdf from the last camera vertex to its ancestor from
            solid angle to surface area.
            </param>
            <returns>MIS weighted next event contribution</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.EmitterHitMis(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,System.Single,System.Single)">
            <summary>
            Computes the MIS weight of randomly hitting an emitter
            </summary>
            <param name="cameraPath">The camera path that hit an emitter</param>
            <param name="pdfEmit">
            Product surface area pdf of sampling the last two vertices of the camera path via emitting a light
            path instead.
            </param>
            <param name="pdfNextEvent">Surface area pdf of sampling the point on the emitter via next event</param>
            <returns>MIS weight</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.OnEmitterHit(SeeSharp.Shading.Emitters.Emitter,SeeSharp.Geometry.SurfacePoint,TinyEmbree.Ray,SeeSharp.Integrators.Bidir.BidirBase.CameraPath,System.Single)">
            <summary>
            Called when a camera path directly intersected an emitter
            </summary>
            <param name="emitter">The emitter that was hit</param>
            <param name="hit">The hit point on the emitter</param>
            <param name="ray">The last ray of the camera path</param>
            <param name="path">The camera path</param>
            <param name="reversePdfJacobian">
            Geometry term to convert a solid angle density on the emitter to a surface area density for
            sampling the previous point along the camera path
            </param>
            <returns>MIS weighted contribution of the emitter</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.OnBackgroundHit(TinyEmbree.Ray,SeeSharp.Integrators.Bidir.BidirBase.CameraPath)">
            <summary>
            Called when a camera path left the scene
            </summary>
            <param name="ray">The last ray of the camera path that intersected nothing</param>
            <param name="path">The camera path</param>
            <returns>MIS weighted contribution from the background</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.OnCameraHit(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,SeeSharp.Sampling.RNG,TinyEmbree.Ray,SeeSharp.Geometry.SurfacePoint,System.Single,SimpleImageIO.RgbColor,System.Int32,System.Single)">
            <summary>
            Called for each surface intersection along a camera path
            </summary>
            <param name="path">The camera path</param>
            <param name="rng">Random number generator</param>
            <param name="ray">The last ray of the camera path</param>
            <param name="hit">The next surface hit point</param>
            <param name="pdfFromAncestor">Solid angle pdf at the previous vertex to sample this ray</param>
            <param name="throughput">
            Product of geometry terms and BSDFs along the path, divided by sampling pdfs.
            </param>
            <param name="depth">The number of edges along the path, 1 for the first intersection</param>
            <param name="toAncestorJacobian">
            Geometry term to convert a solid angle density at this hit point to a surface area density for
            sampling its ancestor.
            </param>
            <returns>Sum of MIS weighted contributions for all sampling techniques performed here</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.BidirBase.OnCameraPathTerminate(SeeSharp.Integrators.Bidir.BidirBase.CameraPath)">
            <summary>
            Called for each termination of the camera path
            </summary>
            <param name="path">The camera path</param>
        </member>
        <member name="T:SeeSharp.Integrators.Bidir.ClassicBidir">
            <summary>
            Implements classic bidirectional path tracing as proposed by Veach and Guibas. Each camera path is
            paired with a light path, and all vertices of both paths are connected pair-wise.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.ClassicBidir.RenderTechniquePyramid">
            <summary>
            Set to true to output the raw images and MIS weighted images of all individual sampling
            techniques. The images will be written to a folder with the same name as the output file.
            Should only be used for debugging, as it is quite expensive.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.ClassicBidir.EnableConnections">
            <summary>
            If set to false, the inner vertices of the paths are no longer connected. That is, only light
            tracing and path tracing with next event are enabled.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.ClassicBidir.EnableLightTracer">
            <summary>
            If set to false, light path vertices are no longer connected directly to the camera.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.ClassicBidir.NumShadowRays">
            <summary>
            Number of shadow rays to use for next event estimation along the camera path. If set to zero,
            no next event estimation is performed.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.ClassicBidir.NextEventPdf(SeeSharp.Geometry.SurfacePoint,SeeSharp.Geometry.SurfacePoint)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.ClassicBidir.SampleNextEvent(SeeSharp.Geometry.SurfacePoint,SeeSharp.Sampling.RNG)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.ClassicBidir.RegisterSample(SimpleImageIO.RgbColor,System.Single,System.Numerics.Vector2,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.ClassicBidir.Render(SeeSharp.Scene)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.ClassicBidir.ProcessPathCache">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.ClassicBidir.OnCameraHit(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,SeeSharp.Sampling.RNG,TinyEmbree.Ray,SeeSharp.Geometry.SurfacePoint,System.Single,SimpleImageIO.RgbColor,System.Int32,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.ClassicBidir.EmitterHitMis(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.ClassicBidir.LightTracerMis(SeeSharp.Integrators.Common.PathVertex,System.Single,System.Single,System.Single,System.Numerics.Vector2,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.ClassicBidir.BidirConnectMis(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,SeeSharp.Integrators.Common.PathVertex,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.ClassicBidir.NextEventMis(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,System.Single,System.Single,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.ClassicBidir.CameraPathReciprocals(System.Int32,SeeSharp.Integrators.BidirPathPdfs,System.Numerics.Vector2)">
            <summary>
            Computes the sum of pdf ratios needed for the balance heuristic weight, along the camera prefix.
            </summary>
            <param name="lastCameraVertexIdx">
            Index of the last vertex that was sampled from the camera, identifies the current technique.
            </param>
            <param name="pdfs">The sampling pdfs along the path</param>
            <param name="pixel">The pixel that this sample contributes to</param>
            <returns>Sum of the pdfs of all other techniques divided by the current technique.</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.ClassicBidir.LightPathReciprocals(System.Int32,SeeSharp.Integrators.BidirPathPdfs,System.Numerics.Vector2)">
            <summary>
            Computes the sum of pdf ratios needed for the balance heuristic weight, along the light suffix.
            </summary>
            <param name="lastCameraVertexIdx">
            Index of the last vertex that was sampled from the camera, identifies the current technique.
            </param>
            <param name="pdfs">The sampling pdfs along the path</param>
            <param name="pixel">The pixel that this sample contributes to</param>
            <returns>Sum of the pdfs of all other techniques divided by the current technique.</returns>
        </member>
        <member name="T:SeeSharp.Integrators.Bidir.LightPathCache">
            <summary>
            Samples a given number of light paths via random walks through a scene.
            The paths are stored in a <see cref="T:SeeSharp.Integrators.Common.PathCache"/>
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.LightPathCache.NumPaths">
            <summary>
            The number of paths that should be traced in each iteration
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.LightPathCache.MaxDepth">
            <summary>
            The maximum length of each path
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.LightPathCache.BaseSeed">
            <summary>
            Seed that is hashed with the iteration and path index to generate a random number sequence
            for each light path.
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.Bidir.LightPathCache.Scene">
            <summary>
            The scene that is being rendered
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.Bidir.LightPathCache.PathCache">
            <summary>
            The generated light paths in the current iteration
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.LightPathCache.SelectLight(System.Single)">
            <summary>
            Maps a primary space random number to an importance sampled emitter in the scene
            </summary>
            <param name="primary">Primary space random number in [0,1]</param>
            <returns>The emitter and its selection probability</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.LightPathCache.SelectLightPmf(SeeSharp.Shading.Emitters.Emitter)">
            <summary>
            Computes the sampling probability used by <see cref="M:SeeSharp.Integrators.Bidir.LightPathCache.SelectLight(System.Single)"/>
            </summary>
            <param name="em">An emitter in the scene</param>
            <returns>The selection probability</returns>
        </member>
        <member name="P:SeeSharp.Integrators.Bidir.LightPathCache.BackgroundProbability">
            <summary>
            Probability of selecting the background instead of a surface emitter
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.LightPathCache.SampleEmitter(SeeSharp.Sampling.RNG,SeeSharp.Shading.Emitters.Emitter)">
            <summary>
            Samples a ray from an emitter in the scene
            </summary>
            <param name="rng">Random number generator</param>
            <param name="emitter">The emitter to sample from</param>
            <returns>Sampled ray, weights, and probabilities</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.LightPathCache.ComputeEmitterPdf(SeeSharp.Shading.Emitters.Emitter,SeeSharp.Geometry.SurfacePoint,System.Numerics.Vector3,System.Single)">
            <summary>
            Computes the importance sampling pdf to generate an edge from a point on an emitter to a point
            in the scene. Result is the product of two surface area densities and a discrete selection
            probability.
            </summary>
            <param name="emitter">An emitter in the scene</param>
            <param name="point">Point on the emitter's surface</param>
            <param name="lightToSurface">Direction from the emitter to the illuminated surface</param>
            <param name="reversePdfJacobian">
            Geometry term to convert the solid angle density on the emitter's surface to a surface area
            density at the illuminated point.
            </param>
            <returns>The full, product surface area density of sampling this ray from the emitter</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.LightPathCache.ComputeBackgroundPdf(System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Computes the pdf of sampling a ray from the background that illuminates a point.
            </summary>
            <param name="from">The illuminated point</param>
            <param name="lightToSurface">Direction from the background to the illuminated point</param>
            <returns>Sampling density (solid angle times discrete)</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.LightPathCache.SampleBackground(SeeSharp.Sampling.RNG)">
            <summary>
            Samples a ray from the background into the scene.
            </summary>
            <param name="rng">Random number generator</param>
            <returns>The sampled ray, its weight, and the sampling pdf</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.LightPathCache.TraceAllPaths(System.UInt32,SeeSharp.Integrators.Bidir.LightPathCache.NextEventPdfCallback)">
            <summary>
            Resets the path cache and populates it with a new set of light paths.
            </summary>
            <param name="iter">Index of the current iteration, used to seed the random number generator.</param>
            <param name="nextEventPdfCallback">
            Delegate that is invoked to compute the next event sampling density
            </param>
        </member>
        <member name="T:SeeSharp.Integrators.Bidir.LightPathCache.NextEventPdfCallback">
            <summary>
            Computes the next event sampling pdf
            </summary>
            <param name="origin">Initial vertex on the light source or background</param>
            <param name="primary">First vertex intersected in the scene</param>
            <param name="nextDirection">Direction towards the next vertex</param>
            <returns>Next event pdf to sample the same edge</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.LightPathCache.TraceLightPath(SeeSharp.Sampling.RNG,SeeSharp.Integrators.Bidir.LightPathCache.NextEventPdfCallback,System.Int32)">
            <summary>
            Called for each light path, used to populate the path cache.
            </summary>
            <returns>
            The index of the last vertex along the path.
            </returns>
        </member>
        <member name="T:SeeSharp.Integrators.Bidir.LightPathCache.ProcessVertex">
            <summary>
            Callback that is invoked for each vertex along a path
            </summary>
            <param name="pathIdx">Index of the full path in the cache</param>
            <param name="vertex">Reference to the vertex</param>
            <param name="ancestor">Reference to the vertex's ancestor</param>
            <param name="dirToAncestor">Normalized direction from the vertex to the ancestor</param>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.LightPathCache.ForEachVertex(System.Int32,SeeSharp.Integrators.Bidir.LightPathCache.ProcessVertex)">
            <summary>
            Utility function that iterates over a light path, starting on the end point, excluding the point on the light itself.
            </summary>
            <param name="index">Index of the light path to iterate over</param>
            <param name="func">Delegate invoked on each vertex</param>
        </member>
        <member name="T:SeeSharp.Integrators.Bidir.PhotonMapper">
            <summary>
            A pure photon mapper in its most naive form: merging at the first camera vertex with a fixed radius
            computed from a fraction of the scene size.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.PhotonMapper.NumIterations">
            <summary>
            Number of iterations to render.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.PhotonMapper.NumLightPaths">
            <summary>
            Number of light paths in each iteration.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.PhotonMapper.BaseSeedLight">
            <summary>
            Seed for the random samples used to generate the photons
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.PhotonMapper.BaseSeedCamera">
            <summary>
            Seed for the random samples used to generate the camera rays
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.PhotonMapper.scene">
            <summary>
            The scene that is currently rendered
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.PhotonMapper.lightPaths">
            <summary>
            Generates and stores the light paths / photons
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.PhotonMapper.Render(SeeSharp.Scene)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.PhotonMapper.ProcessPathCache">
            <summary>
            Builds the photon map from the cached light paths
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.PhotonMapper.EstimatePixelValue(System.Numerics.Vector2,TinyEmbree.Ray,SimpleImageIO.RgbColor,SeeSharp.Sampling.RNG)">
            <summary>
            Computes the estimated radiance travelling along a sampled camera ray
            </summary>
            <param name="pixel">Position on the image plane</param>
            <param name="ray">Ray sampled from the camera</param>
            <param name="weight">Contribution of the ray to the image, multiplied with the radiance</param>
            <param name="rng">Random number generator</param>
            <returns>Pixel value estimate</returns>
        </member>
        <member name="T:SeeSharp.Integrators.Bidir.TechPyramid">
            <summary>
            Stores individual renderings of different MIS techniques
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.TechPyramid.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Initializes a technique pyramid for VCM
            </summary>
            <param name="width">Width of the image in pixels</param>
            <param name="height">Height of the image in pixels</param>
            <param name="minDepth">Minimum path length to track</param>
            <param name="maxDepth">Maximum path length to track</param>
            <param name="merges">If false, ignores merging techniques</param>
            <param name="connections">If false, ignores connections</param>
            <param name="lightTracer">If false, ignores light tracing</param>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.TechPyramid.Add(System.Int32,System.Int32,System.Int32,System.Numerics.Vector2,SimpleImageIO.RgbColor)">
            <summary>
            Logs a sample to the pyramid. Identifies the technique based on the edge counts.
            </summary>
            <param name="cameraPathEdges">Number of edges along the camera subpath</param>
            <param name="lightPathEdges">Number of edges along the light subpath</param>
            <param name="totalEdges">Number of edges in the combined path</param>
            <param name="filmPoint">Position on the image that this path contributes to</param>
            <param name="value">The contribution</param>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.TechPyramid.Normalize(System.Single)">
            <summary>
            Multiplies all pixels in all images by the given factor.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.TechPyramid.WriteToFiles(System.String)">
            <summary>
            Writes the images into separate files
            </summary>
            <param name="basename">First portion of the filenames, will be extended with a per-tech suffix</param>
        </member>
        <member name="T:SeeSharp.Integrators.Bidir.VertexCacheBidir">
            <summary>
            Variation of the bidirectional path tracer that uses the "Light vertex cache" proposed
            by Davidovic et al [2014] "Progressive Light Transport Simulation on the GPU: Survey and Improvements".
            A good basis for algorithms that want to control the number of connections, or the resampling logic.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.VertexCacheBidir.NumConnections">
            <summary>
            Number of connections to make
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.VertexCacheBidir.NumShadowRays">
            <summary>
            Number of shadow rays to use for next event. Disabled if zero.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.VertexCacheBidir.EnableLightTracer">
            <summary>
            Set to false to disable connections between light vertices and the camera
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.VertexCacheBidir.EnableHitting">
            <summary>
            Set to false to disable contributions from camera subpaths intersecting a light
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.VertexCacheBidir.RenderTechniquePyramid">
            <summary>
            If set to true, renders all techniques for all path lengths as separate images, with and without MIS.
            This is expensive and should only be used for debugging purposes.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.VertexCacheBidir.vertexSelector">
            <summary>
            The light vertex resampler
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexCacheBidir.NextEventPdf(SeeSharp.Geometry.SurfacePoint,SeeSharp.Geometry.SurfacePoint)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexCacheBidir.SampleNextEvent(SeeSharp.Geometry.SurfacePoint,SeeSharp.Sampling.RNG)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexCacheBidir.SelectBidirPath(SeeSharp.Geometry.SurfacePoint,System.Numerics.Vector3,System.Numerics.Vector2,SeeSharp.Sampling.RNG)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexCacheBidir.BidirSelectDensity(System.Numerics.Vector2)">
            <summary>
            Computes the effective density of selecting a light path vertex for connection.
            That is, the product of the selection probability and the number of samples.
            </summary>
            <returns>Effective density</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexCacheBidir.RegisterSample(SimpleImageIO.RgbColor,System.Single,System.Numerics.Vector2,System.Int32,System.Int32,System.Int32)">
            <summary>Adds the contribution to the technique pyramid, if enabled</summary>
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexCacheBidir.Render(SeeSharp.Scene)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexCacheBidir.ProcessPathCache">
            <summary>
            Creates the vertex resampler and computes the light tracing contribution.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexCacheBidir.OnCameraHit(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,SeeSharp.Sampling.RNG,TinyEmbree.Ray,SeeSharp.Geometry.SurfacePoint,System.Single,SimpleImageIO.RgbColor,System.Int32,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexCacheBidir.EmitterHitMis(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexCacheBidir.LightTracerMis(SeeSharp.Integrators.Common.PathVertex,System.Single,System.Single,System.Single,System.Numerics.Vector2,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexCacheBidir.BidirConnectMis(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,SeeSharp.Integrators.Common.PathVertex,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexCacheBidir.NextEventMis(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,System.Single,System.Single,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexCacheBidir.CameraPathReciprocals(System.Int32,SeeSharp.Integrators.BidirPathPdfs,System.Numerics.Vector2)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexCacheBidir.LightPathReciprocals(System.Int32,System.Int32,SeeSharp.Integrators.BidirPathPdfs,System.Numerics.Vector2)">
            <inheritdoc />
        </member>
        <member name="T:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging">
            <summary>
            Implements vertex connection and merging (VCM). An MIS combination of bidirectional path tracing
            (we are using the vertex caching flavor) and photon mapping (aka merging).
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.MergePrimary">
            <summary>Whether or not to use merging at the first hit from the camera.</summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.EnableMerging">
            <summary>
            If set to false, no merging (aka photon mapping) is performed. Just plain old BDPT.
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.MaximumRadius">
            <summary>
            The maximum radius used by any merge in the current iteration. Only initialized after rendering started.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.photons">
            <summary>
            Indices of the photons in the scene. To be used in conjunction with <see cref="F:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.photonMap"/>
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.photonMap">
            <summary>
            Acceleration structure to query photons in the scene.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.InitializeRadius(SeeSharp.Scene)">
            <summary>
            Initializes the radius for photon mapping. The default implementation samples three rays
            on the diagonal of the image. The average pixel footprints at these positions are used to compute
            a radius that roughly spans a 3x3 pixel area in the image plane.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.ShrinkRadius(System.UInt32)">
            <summary>
            Override this to make merging use progressive photon mapping, by shrinking the maximum radius
            in each iteration.
            </summary>
            <param name="iteration">The 0-based index of the iteration that just finished.</param>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.OnEndIteration(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.RegisterSample(SimpleImageIO.RgbColor,System.Single,System.Numerics.Vector2,System.Int32,System.Int32,System.Int32)">
            <summary>Splats all non-zero samples into the technique pyramid, if enabled.</summary>
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.Render(SeeSharp.Scene)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.ProcessPathCache">
            <summary>
            Generates the acceleration structure for merging
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.OnMergeSample(SimpleImageIO.RgbColor,System.Single,System.Single,SeeSharp.Integrators.Bidir.BidirBase.CameraPath,SeeSharp.Integrators.Common.PathVertex,System.Single,System.Single,System.Single)">
            <summary>
            Called for each individual merge that yields one full path between the camera and a light.
            </summary>
            <param name="weight">Contribution of the path</param>
            <param name="kernelWeight">The PM kernel value that will be multiplied on the weight</param>
            <param name="misWeight">MIS weight that will be multiplied on the weight</param>
            <param name="cameraPath">The camera subpath</param>
            <param name="lightVertex">The last vertex of the light subpath</param>
            <param name="pdfCameraReverse">
            Surface area PDF to sample the previous vertex along the camera path when coming from the light
            </param>
            <param name="pdfLightReverse">
            Surface are PDF to sample the previous vertex along the light subpath when coming from the camera
            </param>
            <param name="pdfNextEvent">
            If the light vertex is the primary hit after the light source: the surface area PDF of next event
            to sample the same edge. Otherwise zero.
            </param>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.ComputeLocalMergeRadius(System.Single)">
            <summary>
            Shrinks the global maximum radius based on the current camera path.
            </summary>
            <param name="primaryDistance">Distance between the camera and the primary hit point</param>
            <returns>The shrunk radius</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.PerformMerging(TinyEmbree.Ray,SeeSharp.Geometry.SurfacePoint,SeeSharp.Sampling.RNG,SeeSharp.Integrators.Bidir.BidirBase.CameraPath,System.Single)">
             <summary>
            
             </summary>
             <param name="ray">Last ray along the camera path</param>
             <param name="hit">Last hit point along the camera path</param>
             <param name="rng">Random number generator for random decisions required during merging</param>
             <param name="path">The camera subpath data</param>
             <param name="cameraJacobian">
                 Geometry term used to turn a PDF over outgoing directions into a surface area density.
             </param>
             <returns>MIS weighted contribution due to merging</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.OnCameraHit(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,SeeSharp.Sampling.RNG,TinyEmbree.Ray,SeeSharp.Geometry.SurfacePoint,System.Single,SimpleImageIO.RgbColor,System.Int32,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.MergeMis(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,SeeSharp.Integrators.Common.PathVertex,System.Single,System.Single,System.Single)">
            <summary>
            Computes the MIS weight for a merge
            </summary>
            <param name="cameraPath">The camera subpath</param>
            <param name="lightVertex">Last vertex of the light subpath</param>
            <param name="pdfCameraReverse">
            Surface area pdf to sample the previous vertex along the camera subpath when coming from the light
            </param>
            <param name="pdfLightReverse">
            Surface area pdf to sample the previous vertex along the light subpath when coming from the camera
            </param>
            <param name="pdfNextEvent">
            If the light subpath consists of only one edge: the surface area PDF of next event estimation
            </param>
            <returns>MIS weight (classic balance heuristic)</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.EmitterHitMis(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.LightTracerMis(SeeSharp.Integrators.Common.PathVertex,System.Single,System.Single,System.Single,System.Numerics.Vector2,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.BidirConnectMis(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,SeeSharp.Integrators.Common.PathVertex,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.NextEventMis(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,System.Single,System.Single,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.CameraPathReciprocals(System.Int32,SeeSharp.Integrators.BidirPathPdfs,System.Numerics.Vector2,System.Single)">
            <summary>
            Computes the PDF ratios along the camera subpath for MIS weight computations
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexConnectionAndMerging.LightPathReciprocals(System.Int32,SeeSharp.Integrators.BidirPathPdfs,System.Numerics.Vector2,System.Single)">
            <summary>
            Computes the PDF ratios along the light subpath for MIS weight computations
            </summary>
        </member>
        <member name="T:SeeSharp.Integrators.Bidir.VertexSelector">
            <summary>
            Helper class to select random vertices from a path vertex cache.
            Ignores the first vertices of all light paths (the ones on the lights).
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexSelector.#ctor(SeeSharp.Integrators.Common.PathCache)">
            <param name="cache">The light subpath cache</param>
        </member>
        <member name="M:SeeSharp.Integrators.Bidir.VertexSelector.Select(SeeSharp.Sampling.RNG)">
            <summary>
            Randomly selects a light subpath vertex
            </summary>
            <param name="rng">RNG to use</param>
            <returns>Index of the path, index of the vertex along the path</returns>
        </member>
        <member name="P:SeeSharp.Integrators.Bidir.VertexSelector.Count">
            <summary>
            Number of light subpath vertices that can be connected to
            </summary>
        </member>
        <member name="T:SeeSharp.Integrators.BidirPathPdfs">
            <summary>
            Assembles the pdf values in two arrays. The elements of each array
            correspond to the pdf values of sampling each vertex along the path.
            [0] is the primary vertex after the camera
            [numPdfs] is the last vertex, the one on the light source itself.
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.BidirPathPdfs.NumPdfs">
            <summary>
            Number of pdfs along the path
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.BidirPathPdfs.PdfsLightToCamera">
            <summary>
            The surface area pdfs for each vertex along the path, when traced from the light.
            The [i]th value is the pdf of sampling this vertex from its ancestor, which is the [i+1]th value.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.BidirPathPdfs.PdfsCameraToLight">
            <summary>
            The surface area pdf for each vertex along the path, when traced from the camera.
            The [i]th value is the pdf of sampling this vertex from its ancestor, which is the [i-1]th value.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.BidirPathPdfs.#ctor(SeeSharp.Integrators.Common.PathCache,System.Span{System.Single},System.Span{System.Single})">
            <summary>
            Prepares <see langword="this"/> object to compute the pdf values into two preallocated arrays.
            </summary>
            <param name="cache">The cached light paths</param>
            <param name="lightToCam">Pre-allocated memory for the light path pdfs</param>
            <param name="camToLight">Pre-allocated memory for the camera path pdfs</param>
        </member>
        <member name="M:SeeSharp.Integrators.BidirPathPdfs.GatherCameraPdfs(SeeSharp.Integrators.Bidir.BidirBase.CameraPath,System.Int32)">
            <summary>
            Gathers the surface area pdfs along a camera path in our look-up array
            </summary>
            <param name="cameraPath">The camera path</param>
            <param name="lastCameraVertexIdx">
            The index of the last vertex along the path. Can be smaller than the actual length to accumulate
            only the pdfs of a sub-path.
            </param>
        </member>
        <member name="M:SeeSharp.Integrators.BidirPathPdfs.GatherLightPdfs(SeeSharp.Integrators.Common.PathVertex,System.Int32)">
            <summary>
            Gathers the surface area pdfs along a light path into our look-up array
            </summary>
            <param name="lightVertex">The last vertex of the light path</param>
            <param name="lastCameraVertexIdx">
            Index of the last vertex that was sampled via a camera path. Everything after that position
            is filled with the forward and backward sampling pdfs along the light path.
            </param>
        </member>
        <member name="T:SeeSharp.Integrators.Common.CachedRandomWalk">
            <summary>
            Performs a random walk and stores all vertices along the path in a <see cref="T:SeeSharp.Integrators.Common.PathCache" />.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Common.CachedRandomWalk.Cache">
            <summary>
            The cache storing the generated path
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.Common.CachedRandomWalk.LastId">
            <summary>
            Index of the last vertex along the path that was generated
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Common.CachedRandomWalk.PathIdx">
            <summary>
            Index of the generated path in the cache
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Common.CachedRandomWalk.#ctor(SeeSharp.Scene,SeeSharp.Sampling.RNG,System.Int32,SeeSharp.Integrators.Common.PathCache,System.Int32)">
            <summary>
            Prepares an object that can be used to perform one random walk.
            </summary>
            <param name="scene">The scene being rendered</param>
            <param name="rng">RNG used for sampling the path</param>
            <param name="maxDepth">Maximum number of edges along the path</param>
            <param name="cache">The cache to store the path in</param>
            <param name="pathIdx">Index of this path in the cache</param>
        </member>
        <member name="M:SeeSharp.Integrators.Common.CachedRandomWalk.StartFromEmitter(SeeSharp.Shading.Emitters.EmitterSample,SimpleImageIO.RgbColor)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Common.CachedRandomWalk.StartFromBackground(TinyEmbree.Ray,SimpleImageIO.RgbColor,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Common.CachedRandomWalk.OnHit(TinyEmbree.Ray,SeeSharp.Geometry.SurfacePoint,System.Single,SimpleImageIO.RgbColor,System.Int32,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Common.CachedRandomWalk.OnContinue(System.Single,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:SeeSharp.Integrators.Common.PathCache">
            <summary>
            Stores a set of paths consisting of vertices. The capacity is pre-determined. If not all vertices of a
            path fit in the cache, they are discared and the next iteration uses a bigger cache.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Common.PathCache.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes the cache
            </summary>
            <param name="numPaths">The number of paths to store</param>
            <param name="pathCapacity">The (expected) maximum number of vertices along each path</param>
        </member>
        <member name="P:SeeSharp.Integrators.Common.PathCache.Item(System.Int32,System.Int32)">
            <summary>
            By-reference access to a vertex stored in the cache
            </summary>
            <param name="pathIdx">0-based index of the path</param>
            <param name="vertexId">0-based index of the vertex along the path</param>
            <returns>Reference to the path vertex</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Common.PathCache.AddVertex(SeeSharp.Integrators.Common.PathVertex,System.Int32)">
            <summary>
            Extends a path by adding a new vertex
            </summary>
            <param name="vertex">The next vertex</param>
            <param name="pathIdx">Index of the path to extend</param>
            <returns>Index of the new vertex along the path</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Common.PathCache.Clear">
            <summary>
            Deletes all paths
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Common.PathCache.Length(System.Int32)">
            <param name="index">Index of a path</param>
            <returns>The number of vertices along the path</returns>
        </member>
        <member name="P:SeeSharp.Integrators.Common.PathCache.NumPaths">
            <summary>
            The number of paths the cache can store
            </summary>
        </member>
        <member name="T:SeeSharp.Integrators.Common.PathVertex">
            <summary>
            Stores the info of a single vertex of a cached light path
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Common.PathVertex.Point">
            <summary>
            The surface interesection
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Common.PathVertex.PdfFromAncestor">
            <summary>
            Surface area pdf to sample this vertex from the previous one, i.e., the actual density this vertex
            was sampled from
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Common.PathVertex.PdfReverseAncestor">
            <summary> Surface area pdf to sample the ancestor of the previous vertex. </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Common.PathVertex.PdfNextEventAncestor">
            <summary> Surface area pdf of next event estimation at the ancestor (if applicable) </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Common.PathVertex.Weight">
            <summary>
            Accumulated Monte Carlo weight of the sub-path up to and including this vertex
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Common.PathVertex.AncestorId">
            <summary>
            0-based index of the previous vertex along the path, or -1 if there is none
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Common.PathVertex.PathId">
            <summary>
            0-based index of the path this vertex belongs to
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Common.PathVertex.Depth">
            <summary>
            The number of edges along the path.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Common.PathVertex.MaximumRoughness">
            <summary>
            Maximum roughness of the materials at any of the previous vertices and this one.
            </summary>
        </member>
        <member name="T:SeeSharp.Integrators.Common.RandomWalk">
            <summary>
            Performs a recursive random walk, invoking virtual callbacks for events along the path.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Common.RandomWalk.#ctor(SeeSharp.Scene,SeeSharp.Sampling.RNG,System.Int32)">
            <summary>
            Initializes a new random walk
            </summary>
            <param name="scene">The scene</param>
            <param name="rng">RNG used to sample the walk</param>
            <param name="maxDepth">Maximum number of edges along the path</param>
        </member>
        <member name="T:SeeSharp.Integrators.DebugVisualizer">
            <summary>
            Renders a simple and fast grayscale visualization of a scene
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.DebugVisualizer.BaseSeed">
            <summary>
            Base seed used for anti-aliasing
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.DebugVisualizer.TotalSpp">
            <summary>
            Number of anti-aliasing samples to take in each pixel
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.DebugVisualizer.Render(SeeSharp.Scene)">
            <summary>
            Renders the given scene.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.DebugVisualizer.ComputeColor(SeeSharp.Geometry.SurfacePoint,System.Numerics.Vector3)">
            <summary>
            The shading value at a primary hit point. The default implementation uses "eye light shading",
            i.e., the cosine between the outgoing direction and the normal.
            </summary>
        </member>
        <member name="T:SeeSharp.Integrators.Integrator">
            <summary>
            Base class for all rendering algorithms.
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.Integrator.MaxDepth">
            <summary>
            Maximum path length for global illumination algorithms. Default is 5.
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.Integrator.MinDepth">
            <summary>
            Minimum length (in edges) of a path that can contribute to the image. If set to 2, e.g., directly
            visible lights are not rendered. Default is 1.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Integrator.Render(SeeSharp.Scene)">
            <summary>
            Renders a scene to the frame buffer that is specified by the <see cref="T:SeeSharp.Scene" /> object.
            </summary>
            <param name="scene">The scene to render</param>
        </member>
        <member name="T:SeeSharp.Integrators.PathTracer">
            <summary>
            A classic path tracer with next event estimation
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.PathTracer.BaseSeed">
            <summary>
            Used to compute the seeds for all random samplers.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.PathTracer.TotalSpp">
            <summary>
            Number of samples per pixel to render
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.PathTracer.MaximumRenderTimeMs">
            <summary>
            The maximum time in milliseconds that should be spent rendering.
            Excludes framebuffer overhead and other operations that are not part of the core rendering logic.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.PathTracer.NumShadowRays">
            <summary>
            Number of shadow rays to use for next event estimation at each vertex
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.PathTracer.EnableBsdfDI">
            <summary>
            Can be set to false to disable BSDF samples for direct illumination (typically a bad idea to turn
            this off unless to experiment)
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.PathTracer.RenderTechniquePyramid">
            <summary>
            If set to true, renders separate images for each technique combined via multi-sample MIS.
            By default, these are BSDF sampling and next event at every path length.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.PathTracer.EnableDenoiser">
            <summary>
            If set to true (default) runs Intel Open Image Denoise after the end of the last rendering iteration
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.PathTracer.scene">
            <summary>
            The scene that is being rendered.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.PathTracer.RegisterSample(System.Numerics.Vector2,SimpleImageIO.RgbColor,System.Single,System.UInt32,System.Boolean)">
            <summary>
            Called once for each complete path from the camera to a light.
            The default implementation generates a technique pyramid for the MIS samplers.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.PathTracer.OnHit(TinyEmbree.Ray@,TinyEmbree.Hit@,SeeSharp.Integrators.PathTracer.PathState@)">
            <summary>
            Called for every surface hit, before any sampling takes place.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.PathTracer.OnNextEventResult(TinyEmbree.Ray@,SeeSharp.Geometry.SurfacePoint@,SeeSharp.Integrators.PathTracer.PathState@,System.Single,SimpleImageIO.RgbColor)">
            <summary>
            Called whenever direct illumination was estimated via next event estimation
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.PathTracer.OnHitLightResult(TinyEmbree.Ray@,SeeSharp.Integrators.PathTracer.PathState@,System.Single,SimpleImageIO.RgbColor,System.Boolean)">
            <summary>
            Called whenever an emitter was intersected
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.PathTracer.OnStartPath(SeeSharp.Integrators.PathTracer.PathState@)">
            <summary>
            Called before a path is traced, after the initial camera ray was sampled
            </summary>
            <param name="state">Initial state of the path (only pixel and RNG are set)</param>
        </member>
        <member name="M:SeeSharp.Integrators.PathTracer.OnFinishedPath(SeeSharp.Integrators.PathTracer.RadianceEstimate@,SeeSharp.Integrators.PathTracer.PathState@)">
            <summary>
            Called after a path has finished tracing and its contribution was added to the corresponding pixel.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.PathTracer.OnPrepareRender">
            <summary> Called after the scene was submitted, before rendering starts. </summary>
        </member>
        <member name="M:SeeSharp.Integrators.PathTracer.OnPreIteration(System.UInt32)">
            <summary>
            Called before each iteration (one sample per pixel), after the frame buffer was updated.
            </summary>
            <param name="iterIdx">0-based index of the iteration that is about to start</param>
        </member>
        <member name="M:SeeSharp.Integrators.PathTracer.OnPostIteration(System.UInt32)">
            <summary>
            Called at the end of each iteration (one sample per pixel), before the frame buffer is updated.
            </summary>
            <param name="iterIdx">0-based index of the iteration that just ended</param>
        </member>
        <member name="T:SeeSharp.Integrators.PathTracer.PathState">
            <summary>
            Tracks the current state of a path that is being traced
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.PathTracer.PathState.Pixel">
            <summary>
            The pixel this path originated from
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.PathTracer.PathState.Rng">
            <summary>
            Current state of the random number generator
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.PathTracer.PathState.Throughput">
            <summary>
            Product of BSDF terms and cosines, divided by sampling pdfs, along the path so far.
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.PathTracer.PathState.Depth">
            <summary>
            Number of edges (rays) that have been sampled so far
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.PathTracer.PathState.PreviousHit">
            <summary>
            The previous hit point, if the depth is not 1
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.PathTracer.PathState.PreviousPdf">
            <summary>
            The solid angle pdf of the last ray that was sampled (required for MIS)
            </summary>
        </member>
        <member name="T:SeeSharp.Integrators.PathTracer.RadianceEstimate">
            <summary>
            Outgoing radiance estimate at a shading point, split into multiple components
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.PathTracer.RadianceEstimate.Emitted">
            <summary>
            Emitted radiance L_e
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.PathTracer.RadianceEstimate.Reflected">
            <summary>
            Reflected radiance (integral over all directions of incident radiance times BSDF and cosine)
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.PathTracer.RadianceEstimate.NextEventPdf">
            <summary>
            The pdf of computing the direct illumination contribution via next event estimation.
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.PathTracer.RadianceEstimate.Outgoing">
            <summary>
            The full outgoing radiance estimate
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.PathTracer.RadianceEstimate.Absorbed">
            <summary>
            Initializes the structure for a fully black, zero-radiance estimate
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.PathTracer.Render(SeeSharp.Scene)">
            <summary>
            Renders a scene with the current settings. Only one scene can be rendered at a time.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.PathTracer.DirectionPdf(SeeSharp.Geometry.SurfacePoint@,System.Numerics.Vector3,System.Numerics.Vector3,SeeSharp.Integrators.PathTracer.PathState@)">
            <summary>
            Computes the solid angle pdf that <see cref="M:SeeSharp.Integrators.PathTracer.SampleDirection(TinyEmbree.Ray@,SeeSharp.Geometry.SurfacePoint@,SeeSharp.Integrators.PathTracer.PathState@)"/> is using
            </summary>
            <param name="hit">The surface point</param>
            <param name="outDir">Direction the path was coming from</param>
            <param name="sampledDir">Direction that could have been sampled</param>
            <param name="state">The current state of the path</param>
            <returns>Pdf of sampling "sampledDir" when coming from "outDir".</returns>
        </member>
        <member name="M:SeeSharp.Integrators.PathTracer.SampleDirection(TinyEmbree.Ray@,SeeSharp.Geometry.SurfacePoint@,SeeSharp.Integrators.PathTracer.PathState@)">
            <summary>
            Samples a direction to continue the path
            </summary>
            <param name="ray">Previous ray</param>
            <param name="hit">Current hit point</param>
            <param name="state">Current state of the path</param>
            <returns>
            The next ray, its pdf, and the contribution (bsdf * cosine / pdf).
            If sampling was not successful, the pdf will be zero and the path should be terminated.
            </returns>
        </member>
        <member name="T:SeeSharp.Integrators.Util.DenoiseBuffers">
            <summary>
            Convenience wrapper to add common feature buffers to a frame buffer that are useful for denoising.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Util.DenoiseBuffers.#ctor(SeeSharp.Image.FrameBuffer)">
            <summary>
            Adds the required layers to a frame buffer and tracks there references in this object
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Util.DenoiseBuffers.LogPrimaryHit(System.Numerics.Vector2,SimpleImageIO.RgbColor,System.Numerics.Vector3)">
            <summary>
            Logs the features at a primary hit point
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Util.DenoiseBuffers.Denoise">
            <summary>
            Runs the denoiser on the current rendered image. The result is stored in the "denoised" layer.
            </summary>
        </member>
        <member name="T:SeeSharp.Integrators.Util.LoggedPath">
            <summary>
            Stores geometry and contribution of a path sample for later visualization
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Util.LoggedPath.Vertices">
            <summary>
            The positions of the vertices along the path
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Util.LoggedPath.Contribution">
            <summary>
            Contribution of the path to the image
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Util.LoggedPath.UserTypes">
            <summary>
            For each vertex, some user defined number that identifies its "type" (e.g., light path or
            camera path)
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Util.LoggedPath.Copy">
            <returns>A deep copy of this path</returns>
        </member>
        <member name="T:SeeSharp.Integrators.Util.PathLogger">
            <summary>
            Stores paths sampled by an integrator if they fulfill some user-defined filtering condition
            </summary>
        </member>
        <member name="T:SeeSharp.Integrators.Util.PathLogger.FilterFn">
            <summary>
            Filter function used to determine which paths to store
            </summary>
            <returns>True if the path should be stored</returns>
        </member>
        <member name="P:SeeSharp.Integrators.Util.PathLogger.Filter">
            <summary>
            The filter function that determines which paths should be stored
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Util.PathLogger.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new logger that can store arbitrarily many paths per pixel
            </summary>
        </member>
        <member name="T:SeeSharp.Integrators.Util.PathLogger.PathIndex">
            <summary>
            Tracks the index of a path in the per-pixel lists
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.Util.PathLogger.PathIndex.Pixel">
            <summary>
            Index of the pixel
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.Util.PathLogger.PathIndex.Local">
            <summary>
            Index of the path within the pixel
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Util.PathLogger.StartNew(System.Numerics.Vector2)">
            <summary>
            Starts a new path from a pixel
            </summary>
            <returns>Index of the new path</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Util.PathLogger.Split(SeeSharp.Integrators.Util.PathLogger.PathIndex)">
            <summary>
            Logs a splitting event, where one path is continued by multiple suffix paths
            </summary>
            <param name="original">The index of the path so far</param>
            <returns>Index of a new path with identical prefix</returns>
        </member>
        <member name="M:SeeSharp.Integrators.Util.PathLogger.OnEndIteration">
            <summary>
            Removes all paths that do not fulfill the filter conditions
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Util.PathLogger.Continue(SeeSharp.Integrators.Util.PathLogger.PathIndex,System.Numerics.Vector3,System.Int32)">
            <summary>
            Continues the path by adding a new vertex
            </summary>
            <param name="id">ID of the path</param>
            <param name="nextVertex">Position of the next vertex</param>
            <param name="type">User-defined type</param>
        </member>
        <member name="M:SeeSharp.Integrators.Util.PathLogger.SetContrib(SeeSharp.Integrators.Util.PathLogger.PathIndex,SimpleImageIO.RgbColor)">
            <summary>
            Assigns a contribution to a path
            </summary>
            <param name="id">ID of an existing path</param>
            <param name="contrib">The contribution of the path</param>
        </member>
        <member name="M:SeeSharp.Integrators.Util.PathLogger.GetAllInPixel(System.Int32,System.Int32,SimpleImageIO.RgbColor)">
            <returns>All paths stored for the pixel with contribution higher than the minimum</returns>
        </member>
        <member name="T:SeeSharp.Integrators.Util.PathVisualizer">
            <summary>
            Renders an eye-light shaded version of the scene and visualizes a set of paths with one arrow per edge.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Util.PathVisualizer.TypeToColor">
            <summary>
            If set, determines the color of each path type that has an entry in the dictionary.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Util.PathVisualizer.Paths">
            <summary>
            The set of paths to display
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Util.PathVisualizer.Radius">
            <summary>
            Radius of the arrow's cylinder segment, as a fraction of the scene radius.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Util.PathVisualizer.HeadHeight">
            <summary>
            Length of the arrow head, as a fraction of the scene radius.
            </summary>
        </member>
        <member name="F:SeeSharp.Integrators.Util.PathVisualizer.NumSegments">
            <summary>
            Number of quads used to model the cylinder / cone that make up each arrow.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Util.PathVisualizer.Render(SeeSharp.Scene)">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.Integrators.Util.PathVisualizer.ComputeColor(SeeSharp.Geometry.SurfacePoint,System.Numerics.Vector3)">
            <returns>A grayscale color for scene geometry or the color of the intersected path marker</returns>
            <inheritdoc />
        </member>
        <member name="T:SeeSharp.Integrators.Util.RenderTimer">
            <summary>
            Utility to track the time spent rendering and the frame buffer IO overhead separately.
            Can be used to achieve fair equal-time renderings.
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.Util.RenderTimer.FrameBufferTime">
            <summary>
            The total time spent processing the frame buffer so far, in milliseconds.
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.Util.RenderTimer.RenderTime">
            <summary>
            The total time spent in the actual rendering code so far, in milliseconds.
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.Util.RenderTimer.PerIterationCost">
            <summary>
            The estimated cost of a single iteration, in milliseconds.
            </summary>
        </member>
        <member name="P:SeeSharp.Integrators.Util.RenderTimer.CurrentIterationSeconds">
            <summary>
            The total duration of the last iteration (including all overheads) in seconds. This should
            only be used to update progress bars etc, not for equal time rendering.
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Util.RenderTimer.EndFrameBuffer">
            <summary>
            Adds the elapsed time to the frame buffer cost and resets the timer
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Util.RenderTimer.EndRender">
            <summary>
            Adds the elapsed time to the rendering cost and resets the timer
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Util.RenderTimer.StartIteration">
            <summary>
            Starts a new timer for the next iteration
            </summary>
        </member>
        <member name="M:SeeSharp.Integrators.Util.RenderTimer.EndIteration">
            <summary>
            Updates statistics at the end of each iteration
            </summary>
        </member>
        <member name="T:SeeSharp.IO.FbxConverter">
            <summary>
            Loads .fbx geometries via Assimp.NET
            </summary>
        </member>
        <member name="M:SeeSharp.IO.FbxConverter.AddToScene(System.String,SeeSharp.Scene,System.Collections.Generic.Dictionary{System.String,SeeSharp.Shading.Materials.Material},System.Collections.Generic.Dictionary{System.String,SimpleImageIO.RgbColor})">
            <summary>
            Loads a mesh from a .fbx file and adds it to the given scene. Technically, this would also work
            for any other file format supported by Assimp, but we are doing some .fbx specific hacks to achieve
            the correct scale and other conventions.
            </summary>
            <param name="filename">Path to an existing .fbx mesh</param>
            <param name="scene">The scene to which the mesh should be added</param>
            <param name="materialOverride">
                Materials from the .fbx with a name matching one of the keys in this dictionary will be
                replaced by the corresponding dictionary entry
            </param>
            <param name="emissionOverride">
                If a material name is a key in this dictionary, all meshes with that material will be
                converted to diffuse emitters. The value from the dictionary determines their emitted radiance.
            </param>
        </member>
        <member name="T:SeeSharp.IO.IMeshLoader">
            <summary>
            All classes implementing this interface are automatically detected via reflections and used to
            load mesh files with the corresponding type.
            </summary>
        </member>
        <member name="P:SeeSharp.IO.IMeshLoader.Type">
            <summary>
            The type of the mesh file, e.g., "obj" or "ply"
            </summary>
        </member>
        <member name="M:SeeSharp.IO.IMeshLoader.LoadMesh(SeeSharp.Scene,System.Collections.Generic.Dictionary{System.String,SeeSharp.Shading.Materials.Material},System.Collections.Generic.Dictionary{System.String,SimpleImageIO.RgbColor},System.Text.Json.JsonElement,System.String)">
            <summary>
            Loads the mesh and adds it to the scene. Must acquire a lock for resultScene when modifying scene data!
            </summary>
            <param name="resultScene">The loaded mesh is added to this scene, MUST use lock on this object when adding.</param>
            <param name="namedMaterials">Set of materials specified in the scene description</param>
            <param name="jsonElement">The mesh description in the .json file</param>
            <param name="dirname">Full path to the directory containing the .json file</param>
            <param name="emissiveMaterials">All emissive materials in the scene</param>
            <exception cref="T:SeeSharp.IO.MeshLoadException">Thrown if the file is corrupted</exception>
        </member>
        <member name="T:SeeSharp.IO.JsonScene">
            <summary>
            Generates a scene from a .json file
            </summary>
        </member>
        <member name="M:SeeSharp.IO.JsonScene.LoadFromFile(System.String)">
            <summary>
            Creates a scene from a .json
            </summary>
            <param name="path">Full path to the scene description file</param>
            <returns>The scene with all meshes, materials, textures, etc. loaded</returns>
        </member>
        <member name="T:SeeSharp.IO.JsonUtils">
            <summary>
            Methods to deserialize common types in the scene description
            </summary>
        </member>
        <member name="T:SeeSharp.IO.MeshLoadException">
            <summary>
            Represents errors that occur during loading of external meshes.
            </summary>
        </member>
        <member name="P:SeeSharp.IO.MeshLoadException.Path">
            <summary>
            Path to the file which was attempted to be loaded.
            </summary>
        </member>
        <member name="M:SeeSharp.IO.MeshLoadException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the MeshLoadException class with a specified error message and file path.
            </summary>
            <param name="message">The error message string.</param>
            <param name="path">A path to the file which was attempted to be loaded.</param>
        </member>
        <member name="M:SeeSharp.IO.MeshLoadException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the MeshLoadException class with a specified error message, a file path
            and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message string.</param>
            <param name="path">A path to the file which was attempted to be loaded.</param>
            <param name="inner">The exception that is the cause of the current exception,
            or a null reference if no inner exception is specified.</param>
        </member>
        <member name="T:SeeSharp.IO.MixReader">
            <summary>
            Simple class allowing to mix ascii text and binary data reading
            </summary>
        </member>
        <member name="T:SeeSharp.IO.ObjConverter">
            <summary>
            Converts our parsed wavefront .obj mesh representation into an actual mesh.
            Triangulates surfaces and makes sure that one mesh is created for each material.
            </summary>
        </member>
        <member name="P:SeeSharp.IO.ObjConverter.Type">
            <inheritdoc />
        </member>
        <member name="M:SeeSharp.IO.ObjConverter.AddToScene(SeeSharp.IO.ObjMesh,SeeSharp.Scene,System.Collections.Generic.Dictionary{System.String,SeeSharp.Shading.Materials.Material},System.Collections.Generic.Dictionary{System.String,SimpleImageIO.RgbColor})">
            <summary>
            Converts a parsed .obj file into one or more triangle meshes and adds it to the scene.
            We are using our own code and not Assimp.NET, as the latter does not correctly handle meshes
            with multiple materials assigned to different faces.
            </summary>
            <param name="mesh">The parsed .obj mesh</param>
            <param name="scene">The scene to which the mesh should be added</param>
            <param name="materialOverride">
                Materials from the .obj with a name matching one of the keys in this dictionary will be
                replaced by the corresponding dictionary entry
            </param>
            <param name="emissionOverride">
                If a material name is a key in this dictionary, all meshes with that material will be
                converted to diffuse emitters. The value from the dictionary determines their emitted radiance.
            </param>
        </member>
        <member name="T:SeeSharp.IO.ObjMesh">
            <summary>
            Represents a wavefront .obj mesh parsed from a file
            </summary>
        </member>
        <member name="T:SeeSharp.IO.ObjMesh.Index">
            <summary>A reference to a vertex/normal/texture coord. of the model.</summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.Index.VertexIndex">
            <summary> Vertex, normal and texture indices(0 means not present) </summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.Index.NormalIndex">
            <summary> Vertex, normal and texture indices(0 means not present) </summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.Index.TextureIndex">
            <summary> Vertex, normal and texture indices(0 means not present) </summary>
        </member>
        <member name="M:SeeSharp.IO.ObjMesh.Index.GetHashCode">
            <summary>
            Computes a hash for the index by combining hashes of the three integer values
            </summary>
        </member>
        <member name="M:SeeSharp.IO.ObjMesh.Index.Equals(System.Object)">
            <returns>True if the other object is an Index with all values equal</returns>
        </member>
        <member name="T:SeeSharp.IO.ObjMesh.Face">
            <summary>
            A face with arbitrarily many vertices, given by a list of indices, and a material index
            </summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.Face.Indices">
            <summary> Indices of the face </summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.Face.Material">
            <summary> Index into the material names of the model </summary>
        </member>
        <member name="T:SeeSharp.IO.ObjMesh.Group">
            <summary>A group of faces in the model.</summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.Group.Name">
            <summary>
            Name of the group as it is defined in the obj
            </summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.Group.Faces">
            <summary>
            All faces in the group
            </summary>
        </member>
        <member name="M:SeeSharp.IO.ObjMesh.Group.#ctor(System.String)">
            <summary>
            Creates a new group with the given name
            </summary>
        </member>
        <member name="T:SeeSharp.IO.ObjMesh.Object">
            <summary>A object in the model, made of several groups.</summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.Object.Name">
            <summary>
            Name of the object as it is defined in the .obj
            </summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.Object.Groups">
            <summary>
            List of all groups in the object
            </summary>
        </member>
        <member name="M:SeeSharp.IO.ObjMesh.Object.#ctor(System.String)">
            <summary>
            Creates a new object with the given name
            </summary>
        </member>
        <member name="T:SeeSharp.IO.ObjMesh.Material">
            <summary>
            Material data parsed from an associated .mtl file
            </summary>
        </member>
        <member name="T:SeeSharp.IO.ObjMesh.File">
            <summary>
            Represents an entire parsed .obj file
            </summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.File.Objects">
            <summary>
            All objects in the file
            </summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.File.Vertices">
            <summary>
            All vertices in the entire file
            </summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.File.Normals">
            <summary>
            Shading normals of all vertices
            </summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.File.Texcoords">
            <summary>
            Texture coordinates of all vertices
            </summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.File.Materials">
            <summary>
            Names of all materials in the file
            </summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.File.MtlFiles">
            <summary>
            Names of all .mtl files associated to this .obj
            </summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.File.MaterialLib">
            <summary>
            Look-up table for parsed .mtl data for each material name
            </summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.Contents">
            <summary>
            Parsed file contents
            </summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.BasePath">
            <summary>
            Directory containing the .obj. Required to find textures with relative paths
            </summary>
        </member>
        <member name="F:SeeSharp.IO.ObjMesh.Errors">
            <summary>
            List of potential errors encountered during parsing
            </summary>
        </member>
        <member name="M:SeeSharp.IO.ObjMesh.FromFile(System.String)">
            <summary>
            Loads a wavefront .obj file
            </summary>
            <param name="filename">Path to an existing .obj file</param>
        </member>
        <member name="T:SeeSharp.IO.PlyFile">
            <summary>
            Represents an entire parsed .ply file
            Note, we ignore vertex color or other auxilary information
            </summary>
        </member>
        <member name="T:SeeSharp.IO.PlyFile.Face">
            <summary>
            A face with arbitrarily many vertices, given by a list of indices
            </summary>
        </member>
        <member name="F:SeeSharp.IO.PlyFile.Face.Indices">
            <summary> Indices of the face </summary>
        </member>
        <member name="F:SeeSharp.IO.PlyFile.Faces">
            <summary>
            All faces in the file
            </summary>
        </member>
        <member name="F:SeeSharp.IO.PlyFile.Vertices">
            <summary>
            All vertices in the entire file
            </summary>
        </member>
        <member name="F:SeeSharp.IO.PlyFile.Normals">
            <summary>
            Shading normals of all vertices
            </summary>
        </member>
        <member name="F:SeeSharp.IO.PlyFile.Texcoords">
            <summary>
            Texture coordinates of all vertices
            </summary>
        </member>
        <member name="M:SeeSharp.IO.PlyFile.ParseFile(System.String)">
            <summary>
            Loads .ply file and returns list of errors
            </summary>
            <param name="filename"></param>
            <returns>True if successful</returns>
        </member>
        <member name="M:SeeSharp.IO.PlyFile.ToMesh">
            <summary>
            Constructs mesh from previously loaded file content
            </summary>
            <returns>A mesh</returns>
        </member>
        <member name="M:SeeSharp.IO.PlyFile.ToTriangleList">
            <summary>
            Construct list of triangle indices from convex polygons
            </summary>
        </member>
        <member name="T:SeeSharp.IO.PlyFile.IDataReader">
            <summary>
            Interface to read binary and ascii based data region
            </summary>
        </member>
        <member name="T:SeeSharp.IO.PlyFile.AsciiDataReader">
            <summary>
            Data reader for ascii based files
            </summary>
        </member>
        <member name="T:SeeSharp.IO.PlyFile.BinaryDataReader">
            <summary>
            Data reader for binary based files
            </summary>
        </member>
        <member name="T:SeeSharp.IO.PlyFile.PlyHeader">
            <summary>
            Essential informations from the .ply header which is always given in ascii format
            </summary>
        </member>
        <member name="M:SeeSharp.IO.PlyFile.IsAllowedMethod(System.String)">
            <summary>
            Returns true if the method of the data region is feasible
            </summary>
        </member>
        <member name="M:SeeSharp.IO.PlyFile.IsAllowedVertCountType(System.String)">
            <summary>
            Returns true if the counter type for lists is supported
            </summary>
        </member>
        <member name="M:SeeSharp.IO.PlyFile.IsAllowedVertIndType(System.String)">
            <summary>
            Returns true if the index type for lists is supported
            </summary>
        </member>
        <member name="M:SeeSharp.IO.PlyFile.ParsePlyHeader(SeeSharp.IO.MixReader)">
            <summary>
            Will parse the header and populate the PlyHeader structure
            </summary>
            <param name="stream"></param>
            <returns>PlyHeader or null if error</returns>
        </member>
        <member name="M:SeeSharp.IO.PlyFile.ParsePlyFile(SeeSharp.IO.MixReader)">
            <summary>
            Will parse the whole file, starting with the header and following up with the data region
            </summary>
            <param name="stream"></param>
            <returns>True if successful</returns>
        </member>
        <member name="T:SeeSharp.IO.PlyLoader">
            <summary>
            Loads a mesh from a binary or ASCII .ply file
            </summary>
        </member>
        <member name="T:SeeSharp.Sampling.PiecewiseConstant">
            <summary>
            A piece-wise constant PDF / discrete probability to sample from
            </summary>
        </member>
        <member name="M:SeeSharp.Sampling.PiecewiseConstant.#ctor(System.ReadOnlySpan{System.Single})">
            <summary>
            Initializes the piece-wise constant pdf over the [0, 1] domain, where each piece has the same length.
            The given weights are normalized and the CDF is computed.
            </summary>
            <param name="weights">The non-normalized weights of each bin</param>
        </member>
        <member name="M:SeeSharp.Sampling.PiecewiseConstant.#ctor(System.Single[])">
            <summary>
            Initializes the piece-wise constant pdf over the [0, 1] domain, where each piece has the same length.
            The given weights are normalized and the CDF is computed.
            </summary>
            <param name="weights">The non-normalized weights of each bin</param>
        </member>
        <member name="M:SeeSharp.Sampling.PiecewiseConstant.Sample(System.Single)">
            <summary>
            Transforms a primary sample to one distributed according to the
            piecewise constant density encoded by this object.
            </summary>
            <param name="primarySample">A primary sample in [0,1]</param>
            <returns>The bin index, and the relative position within the bin.</returns>
        </member>
        <member name="M:SeeSharp.Sampling.PiecewiseConstant.SampleInverse(System.Int32,System.Single)">
            <summary>
            Performs the inverse of the transform used by <see cref="M:SeeSharp.Sampling.PiecewiseConstant.Sample(System.Single)"/>.
            </summary>
            <param name="idx">The bin index</param>
            <param name="relative">Position within the bin</param>
            <returns>The primary sample that is mapped to this position</returns>
        </member>
        <member name="M:SeeSharp.Sampling.PiecewiseConstant.Probability(System.Int32)">
            <param name="idx">Index of a bin</param>
            <returns>The probability that any sampled point lies within the bin</returns>
        </member>
        <member name="T:SeeSharp.Sampling.RegularGrid2d">
            <summary>
            A regular grid on the unit square.
            Useful for describing 2D pdfs in primary sample space.
            </summary>
        </member>
        <member name="M:SeeSharp.Sampling.RegularGrid2d.Sample(System.Numerics.Vector2)">
            <summary>
            Applies the primary space sample warp that is described by this grid.
            </summary>
            <param name="primary">Primary space sample location</param>
            <returns>The sample position in the 2d unit square</returns>
        </member>
        <member name="M:SeeSharp.Sampling.RegularGrid2d.Splat(System.Single,System.Single,System.Single)">
            <summary>
            Records a density value at a given position.
            The tabulated distribution will no longer be normalized after calling this function.
            </summary>
            <param name="x">Horizontal position on the 2d unit square</param>
            <param name="y">Vertical position on the 2d unit square</param>
            <param name="value">Pdf value to record</param>
        </member>
        <member name="T:SeeSharp.Sampling.RegularGrid3d">
            <summary>
            A regular grid on the unit cube.
            Useful for describing 3D pdfs in primary sample space.
            </summary>
        </member>
        <member name="T:SeeSharp.Sampling.RNG">
            <summary>
            Uniform random number generator. Uses PCG and FNV hashing to efficiently generate random numbers
            even with highly correlated seeds (e.g., consecutive numbers).
            </summary>
        </member>
        <member name="M:SeeSharp.Sampling.RNG.#ctor(System.UInt32)">
            <summary>
            Creates a new random generator with either the given seed or a constant default value.
            </summary>
        </member>
        <member name="M:SeeSharp.Sampling.RNG.#ctor(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Computes a new seed by hashing. Hashes each individual component using PCG to reduce correlation
            and then hashes the three resulting PCG hashes using FNV to achieve a single 32 bit value.
            </summary>
            <param name="baseSeed">A global base seed</param>
            <param name="chainIndex">e.g., a pixel index</param>
            <param name="sampleIndex">current sample within the, e.g., pixel</param>
        </member>
        <member name="M:SeeSharp.Sampling.RNG.NextFloat(System.Single,System.Single)">
            <summary>
            Comptues a random floating point value between two numbers
            </summary>
            <param name="min">Minimum value (inclusive)</param>
            <param name="max">Maximum value (inclusive)</param>
        </member>
        <member name="M:SeeSharp.Sampling.RNG.NextFloat">
            <returns>A floating point value in [0,1] (inclusive)</returns>
        </member>
        <member name="M:SeeSharp.Sampling.RNG.NextFloat2D">
            <returns>A pair of floating point values in [0,1] (inclusive)</returns>
        </member>
        <member name="M:SeeSharp.Sampling.RNG.NextFloat3D">
            <returns>A triple of floating point values in [0,1] (inclusive)</returns>
        </member>
        <member name="M:SeeSharp.Sampling.RNG.NextInt(System.Int32,System.Int32)">
            <summary>Random number from min (inclusive) to max (exclusive)</summary>
        </member>
        <member name="T:SeeSharp.Sampling.SampleWarp">
            <summary>
            Offers functions to transform uniform samples to other distributions or spaces.
            </summary>
        </member>
        <member name="M:SeeSharp.Sampling.SampleWarp.SphericalToCartesian(System.Numerics.Vector2)">
            <summary>
            Converts a direction vector from spherical coordinates to cartesian coordinates.
            </summary>
            <param name="spherical">A vector where X is the longitude (phi) and Y the latitude (theta)</param>
            <returns>Cartesian coordinates in a right handed system (z is up)</returns>
        </member>
        <member name="M:SeeSharp.Sampling.SampleWarp.CartesianToSpherical(System.Numerics.Vector3)">
            <summary>
            Maps the cartensian coordinates (z is up) to spherical coordinates.
            </summary>
            <param name="dir">Direction in cartesian coordinates</param>
            <returns>A vector where X is the longitude (phi) and Y the latitude (theta)</returns>
        </member>
        <member name="M:SeeSharp.Sampling.SampleWarp.ToConcentricDisc(System.Numerics.Vector2)">
            <summary>
            Warps a primary sample to a position on the unit disc.
            </summary>
        </member>
        <member name="M:SeeSharp.Sampling.SampleWarp.SurfaceAreaToSolidAngle(SeeSharp.Geometry.SurfacePoint,SeeSharp.Geometry.SurfacePoint)">
             <summary>
             Computes the inverse jacobian for the mapping from surface area around "to" to the sphere around "from".
            
             Required for integrals that perform this change of variables (e.g., next event estimation).
            
             Multiplying solid angle pdfs by this value computes the corresponding surface area density.
             Dividing surface area pdfs by this value computes the corresponding solid angle density.
            
             This function simply computes the cosine formed by the normal at "to" and the direction from "to" to "from".
             The absolute value of that cosine is then divided by the squared distance between the two points:
            
             result = cos(normal_to, from - to) / ||from - to||^2
             </summary>
             <param name="from">The position at which the hemispherical distribution is defined.</param>
             <param name="to">The point on the surface area that is projected onto the hemisphere.</param>
             <returns>Inverse jacobian, multiply solid angle densities by this value.</returns>
        </member>
        <member name="T:SeeSharp.Scene">
            <summary>
            Manages all information required to render a scene. Each object is meant to be used to render one
            image. But shallow copies can be made (with replaced frame buffers) to re-render the same scene.
            </summary>
        </member>
        <member name="P:SeeSharp.Scene.FrameBuffer">
            <summary>
            The frame buffer that will receive the rendered image. Ownership of the framebuffer is
            transferred to this object, i.e., the framebuffer will be disposed along with this scene or
            when it is replaced.
            </summary>
        </member>
        <member name="F:SeeSharp.Scene.Camera">
            <summary>
            The camera, which models how the frame buffer receives light from the scene
            </summary>
        </member>
        <member name="F:SeeSharp.Scene.Meshes">
            <summary>
            All meshes in the scene. There needs to be at least one.
            </summary>
        </member>
        <member name="P:SeeSharp.Scene.Raytracer">
            <summary>
            Acceleration structure for ray tracing the meshes
            </summary>
        </member>
        <member name="P:SeeSharp.Scene.Emitters">
            <summary>
            All emitters in the scene. There needs to be at least one, unless a background is given.
            </summary>
        </member>
        <member name="F:SeeSharp.Scene.Background">
            <summary>
            Defines radiance from rays that leave the scene. Must be given if no emitters are present.
            </summary>
        </member>
        <member name="P:SeeSharp.Scene.Center">
            <summary>
            Center of the geometry in the scene. Computed by <see cref="M:SeeSharp.Scene.Prepare"/>
            </summary>
        </member>
        <member name="P:SeeSharp.Scene.Radius">
            <summary>
            Radius of the scene bounding sphere. Computed by <see cref="M:SeeSharp.Scene.Prepare"/>
            </summary>
        </member>
        <member name="P:SeeSharp.Scene.Bounds">
            <summary>
            Axis aligned bounding box of the scene. Computed by <see cref="M:SeeSharp.Scene.Prepare"/>
            </summary>
        </member>
        <member name="P:SeeSharp.Scene.ValidationErrorMessages">
            <summary>
            If <see cref="P:SeeSharp.Scene.IsValid"/> is false, this list will contain all error messages found during validation.
            </summary>
        </member>
        <member name="M:SeeSharp.Scene.Copy">
            <summary>
            Creates a semi-deep copy of the scene. That is, a shallow copy except that all lists of references
            are copied into new lists of references. So meshes in the new scene can be removed or added.
            The <see cref="P:SeeSharp.Scene.FrameBuffer" /> and <see cref="P:SeeSharp.Scene.Raytracer" /> are not copied and set to null, to
            avoid any conflicts. The scene is in an invalid state untill <see cref="M:SeeSharp.Scene.Prepare" /> is called.
            </summary>
            <returns>A copy of the scene</returns>
        </member>
        <member name="M:SeeSharp.Scene.Prepare">
            <summary>
            Prepares the scene for rendering. Checks that there is no missing data, builds acceleration
            structures, etc.
            </summary>
        </member>
        <member name="P:SeeSharp.Scene.IsValid">
            <summary>
            True, if the scene is valid. Any errors found whil accessing the property will be
            reported in the <see cref="P:SeeSharp.Scene.ValidationErrorMessages"/> list.
            </summary>
        </member>
        <member name="M:SeeSharp.Scene.QueryEmitter(SeeSharp.Geometry.SurfacePoint)">
            <summary>
            Returns the emitter attached to the mesh on which a <see cref="T:SeeSharp.Geometry.SurfacePoint"/> lies.
            </summary>
            <param name="point">A point on a mesh surface.</param>
            <returns>The attached emitter reference, or null.</returns>
        </member>
        <member name="M:SeeSharp.Scene.LoadFromFile(System.String)">
            <summary>
            Loads a .json file and parses it as a scene. Assumes the file has been validated against
            the correct schema.
            </summary>
            <param name="path">Path to the .json scene file.</param>
            <returns>The scene created from the file.</returns>
        </member>
        <member name="M:SeeSharp.Scene.Dispose">
            <summary>
            Frees all unmanaged resources in the `FrameBuffer` and `Raytracer`
            </summary>
        </member>
        <member name="T:SeeSharp.Shading.Background.Background">
            <summary>
            Base class for all sorts of sky models, image based lighting, etc.
            </summary>
        </member>
        <member name="M:SeeSharp.Shading.Background.Background.EmittedRadiance(System.Numerics.Vector3)">
            <summary>
            Computes the emitted radiance from a given direction. All backgrounds are invariant with respect to the position.
            </summary>
        </member>
        <member name="M:SeeSharp.Shading.Background.Background.RayPdf(System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Computes the pdf value for sampling a ray from the background towards the scene.
            </summary>
            <param name="point">A point along the ray. Could be the start, end, or some other point.</param>
            <param name="direction">Direction of the ray (i.e., from the background to the scene).</param>
            <returns></returns>
        </member>
        <member name="T:SeeSharp.Shading.Background.EnvironmentMap">
             <summary>
             Background that provides image based lighting to the scene.
            
             The image is interpreted as a lat-long map.
             The vertical axis corresponds to the latidude, the horizontal axis to the longitude.
             The "up" direction (top center pixel of the image) corresponds to the worldspace
             positive y direction.
             The longitude is measured such that an angle of zero indicates a direction along the
             worldspace negative x axis. Rotation is CCW about the y axis, when looking along positive y.
             </summary>
        </member>
        <member name="M:SeeSharp.Shading.Background.EnvironmentMap.BuildSamplingGrid(SimpleImageIO.RgbImage)">
            <summary>
            Forms a tabulated pdf to importance sample the given image.
            </summary>
            <param name="image">The source image to importance sample</param>
            <returns>Tabulated pdf for the image.</returns>
        </member>
        <member name="F:SeeSharp.Shading.Background.EnvironmentMap.Image">
            <summary>
            The image that illuminates the scene from all directions
            </summary>
        </member>
        <member name="F:SeeSharp.Shading.Bsdfs.BsdfSample.weight">
            <summary>
            Sample weight of the reflectance estimate, i.e., the product of
            BSDF and shading cosine divided by the pdf.
            </summary>
        </member>
        <member name="T:SeeSharp.Shading.Bsdfs.MicrofacetTransmission">
            <summary>
            Transmission through rough glass using GGX, based heavily on PBRTv3
            </summary>
        </member>
        <member name="T:SeeSharp.Shading.Emitters.DiffuseEmitter">
            <summary>
            Emits a constant amount of radiance in all directions of the upper hemisphere, defined by the
            shading normal of the emissive mesh surface.
            </summary>
        </member>
        <member name="M:SeeSharp.Shading.Emitters.DiffuseEmitter.#ctor(SeeSharp.Geometry.Mesh,SimpleImageIO.RgbColor)">
            <param name="mesh">The emissive mesh</param>
            <param name="radiance">Emitted radiance in all directions</param>
        </member>
        <member name="F:SeeSharp.Shading.Emitters.DiffuseEmitter.Radiance">
            <summary>
            The radiance that is emitted in all directions
            </summary>
        </member>
        <member name="T:SeeSharp.Shading.Emitters.Emitter">
            <summary>
            Base class for types of emissive surface properties
            </summary>
        </member>
        <member name="F:SeeSharp.Shading.Emitters.Emitter.Mesh">
            <summary>
            The mesh that is emitting light
            </summary>
        </member>
        <member name="M:SeeSharp.Shading.Emitters.Emitter.SampleArea(System.Numerics.Vector2)">
            <summary>
            Samples a point on the mesh, ideally proportionally to its emission strength.
            </summary>
            <param name="primary">A uniform sample in [0,1]x[0,1]</param>
        </member>
        <member name="M:SeeSharp.Shading.Emitters.Emitter.SampleAreaInverse(SeeSharp.Geometry.SurfacePoint)">
            <summary>
            Performs the inverse transformation that is done by <see cref="M:SeeSharp.Shading.Emitters.Emitter.SampleArea(System.Numerics.Vector2)"/>
            </summary>
            <param name="point">A point on a surface of the emissive mesh</param>
            <returns>The uniform sample in [0,1]x[0,1]</returns>
        </member>
        <member name="M:SeeSharp.Shading.Emitters.Emitter.PdfArea(SeeSharp.Geometry.SurfacePoint)">
            <param name="point">A point on the surface of the emissive mesh</param>
            <returns>The PDF of sampling this point</returns>
        </member>
        <member name="M:SeeSharp.Shading.Emitters.Emitter.SampleRay(System.Numerics.Vector2,System.Numerics.Vector2)">
            <summary>
            Samples an emitted ray by sampling a point on the mesh and a direction for that point
            </summary>
            <param name="primaryPos">Uniform sample in [0,1]x[0,1] used to sample the point</param>
            <param name="primaryDir">Uniform sample in [0,1]x[0,1] used to sample the direction</param>
            <returns>Sampled ray and associated weights</returns>
        </member>
        <member name="M:SeeSharp.Shading.Emitters.Emitter.SampleRayInverse(SeeSharp.Geometry.SurfacePoint,System.Numerics.Vector3)">
            <summary>
            Performs the inverse transformation that is done by <see cref="M:SeeSharp.Shading.Emitters.Emitter.SampleRayInverse(SeeSharp.Geometry.SurfacePoint,System.Numerics.Vector3)"/>
            </summary>
            <param name="point">A position on the emissive mesh</param>
            <param name="direction">The direction of the ray from that position</param>
            <returns>Uniform random numbers mapped to these coordinates: (pos, dir)</returns>
        </member>
        <member name="M:SeeSharp.Shading.Emitters.Emitter.PdfRay(SeeSharp.Geometry.SurfacePoint,System.Numerics.Vector3)">
            <returns>The PDF value used by <see cref="M:SeeSharp.Shading.Emitters.Emitter.SampleRay(System.Numerics.Vector2,System.Numerics.Vector2)"/></returns>
        </member>
        <member name="M:SeeSharp.Shading.Emitters.Emitter.EmittedRadiance(SeeSharp.Geometry.SurfacePoint,System.Numerics.Vector3)">
            <returns>The amount of radiance emitted by the point in the given direction</returns>
        </member>
        <member name="M:SeeSharp.Shading.Emitters.Emitter.ComputeTotalPower">
            <summary>
            Computes or estimates the total emissive power
            </summary>
        </member>
        <member name="T:SeeSharp.Shading.DisneyFresnel">
            <summary>
            Specialized Fresnel function used for the specular component, based on
            a mixture between dielectric and the Schlick Fresnel approximation.
            </summary>
        </member>
        <member name="T:SeeSharp.Shading.Materials.DiffuseMaterial">
            <summary>
            A simple Lambertian material that either only reflects or only transmits.
            </summary>
        </member>
        <member name="T:SeeSharp.Shading.Materials.DiffuseMaterial.Parameters">
            <summary>
            Specifies the color and whether the material transmits or reflects
            </summary>
        </member>
        <member name="F:SeeSharp.Shading.Materials.DiffuseMaterial.Parameters.BaseColor">
            <summary>
            Scattering color
            </summary>
        </member>
        <member name="F:SeeSharp.Shading.Materials.DiffuseMaterial.Parameters.Transmitter">
            <summary>
            If true, only transmittance happens, if false, only reflection
            </summary>
        </member>
        <member name="M:SeeSharp.Shading.Materials.DiffuseMaterial.IsTransmissive(SeeSharp.Geometry.SurfacePoint@)">
            <returns>True if we only transmit</returns>
        </member>
        <member name="M:SeeSharp.Shading.Materials.DiffuseMaterial.#ctor(SeeSharp.Shading.Materials.DiffuseMaterial.Parameters)">
            <summary>
            Creates a new diffuse material with the given parameters
            </summary>
        </member>
        <member name="M:SeeSharp.Shading.Materials.DiffuseMaterial.GetRoughness(SeeSharp.Geometry.SurfacePoint@)">
            <returns>Always 1</returns>
        </member>
        <member name="M:SeeSharp.Shading.Materials.DiffuseMaterial.GetIndexOfRefractionRatio(SeeSharp.Geometry.SurfacePoint@)">
            <returns>Always 1</returns>
        </member>
        <member name="M:SeeSharp.Shading.Materials.DiffuseMaterial.GetScatterStrength(SeeSharp.Geometry.SurfacePoint@)">
            <returns>The base color</returns>
        </member>
        <member name="M:SeeSharp.Shading.Materials.DiffuseMaterial.Evaluate(SeeSharp.Geometry.SurfacePoint@,System.Numerics.Vector3,System.Numerics.Vector3,System.Boolean)">
            <returns>1/pi * baseColor, or zero if the directions are not in the right hemispheres</returns>
        </member>
        <member name="M:SeeSharp.Shading.Materials.DiffuseMaterial.Sample(SeeSharp.Geometry.SurfacePoint@,System.Numerics.Vector3,System.Boolean,System.Numerics.Vector2)">
            <summary>
            Importance samples the cosine hemisphere
            </summary>
        </member>
        <member name="M:SeeSharp.Shading.Materials.DiffuseMaterial.Pdf(SeeSharp.Geometry.SurfacePoint@,System.Numerics.Vector3,System.Numerics.Vector3,System.Boolean)">
            <returns>PDF value used by <see cref="M:SeeSharp.Shading.Materials.DiffuseMaterial.Sample(SeeSharp.Geometry.SurfacePoint@,System.Numerics.Vector3,System.Boolean,System.Numerics.Vector2)"/></returns>
        </member>
        <member name="F:SeeSharp.Shading.Materials.DiffuseMaterial.MaterialParameters">
            <summary>
            Material parameters
            </summary>
        </member>
        <member name="T:SeeSharp.Shading.Materials.GenericMaterial">
            <summary>
            Basic uber-shader surface material that should suffice for most integrator experiments.
            Simplified version of the Disney BSDF without sheen and clearcoat and limited texturing capabilities.
            </summary>
        </member>
        <member name="T:SeeSharp.Shading.Materials.GenericMaterial.Parameters">
            <summary>
            Parameters of the generic material
            </summary>
        </member>
        <member name="F:SeeSharp.Shading.Materials.GenericMaterial.Parameters.BaseColor">
            <summary>
            Textured or constant surface color. Affects diffuse reflections and also specular ones,
            if <see cref="F:SeeSharp.Shading.Materials.GenericMaterial.Parameters.SpecularTintStrength"/> is greater than zero.
            </summary>
        </member>
        <member name="F:SeeSharp.Shading.Materials.GenericMaterial.Parameters.Roughness">
            <summary>
            Textured or constant surface roughness. Perfect mirrors would be 0 and purely diffuse 1.
            </summary>
        </member>
        <member name="F:SeeSharp.Shading.Materials.GenericMaterial.Parameters.Metallic">
            <summary>
            Interpolates between conductor and dielectric Fresnel.
            </summary>
        </member>
        <member name="F:SeeSharp.Shading.Materials.GenericMaterial.Parameters.SpecularTintStrength">
            <summary>
            How much the base color affects specular reflections. If 0, specular reflections will be white.
            </summary>
        </member>
        <member name="F:SeeSharp.Shading.Materials.GenericMaterial.Parameters.Anisotropic">
            <summary>
            Amount of anisotropy in the glossy microfacet components
            </summary>
        </member>
        <member name="F:SeeSharp.Shading.Materials.GenericMaterial.Parameters.SpecularTransmittance">
            <summary>
            If greater than one, the surface transmits with a rough GGX dielectric
            </summary>
        </member>
        <member name="F:SeeSharp.Shading.Materials.GenericMaterial.Parameters.IndexOfRefraction">
            <summary>
            IOR of the material "below" the surface. Assumes that the exterior is always vacuum (1).
            </summary>
        </member>
        <member name="F:SeeSharp.Shading.Materials.GenericMaterial.Parameters.Thin">
            <summary>
            If set to true, transmission will also happen diffusely, i.e., this is a translucent
            material like paper.
            </summary>
        </member>
        <member name="F:SeeSharp.Shading.Materials.GenericMaterial.Parameters.DiffuseTransmittance">
            <summary>
            Scaling factor for how much light is diffusely transmitted through the surface. Only
            relvant if <see cref="F:SeeSharp.Shading.Materials.GenericMaterial.Parameters.Thin"/> is true.
            </summary>
        </member>
        <member name="M:SeeSharp.Shading.Materials.GenericMaterial.#ctor(SeeSharp.Shading.Materials.GenericMaterial.Parameters)">
            <param name="parameters">Properties of the material</param>
        </member>
        <member name="M:SeeSharp.Shading.Materials.GenericMaterial.GetRoughness(SeeSharp.Geometry.SurfacePoint@)">
            <returns>The textured roughness value at the hit point </returns>
        </member>
        <member name="M:SeeSharp.Shading.Materials.GenericMaterial.IsTransmissive(SeeSharp.Geometry.SurfacePoint@)">
            <returns>True if the material is "thin" or the specular transmittance is not zero</returns>
        </member>
        <member name="M:SeeSharp.Shading.Materials.GenericMaterial.GetIndexOfRefractionRatio(SeeSharp.Geometry.SurfacePoint@)">
            <returns>Interior IOR, assumes outside is vacuum</returns>
        </member>
        <member name="M:SeeSharp.Shading.Materials.GenericMaterial.GetScatterStrength(SeeSharp.Geometry.SurfacePoint@)">
            <returns>The base color, which is a crude approximation of the scattering strength</returns>
        </member>
        <member name="M:SeeSharp.Shading.Materials.GenericMaterial.Evaluate(SeeSharp.Geometry.SurfacePoint@,System.Numerics.Vector3,System.Numerics.Vector3,System.Boolean)">
            <returns>BSDF value</returns>
        </member>
        <member name="M:SeeSharp.Shading.Materials.GenericMaterial.Sample(SeeSharp.Geometry.SurfacePoint@,System.Numerics.Vector3,System.Boolean,System.Numerics.Vector2)">
            <summary>Crudely importance samples the combined BSDFs</summary>
        </member>
        <member name="M:SeeSharp.Shading.Materials.GenericMaterial.Pdf(SeeSharp.Geometry.SurfacePoint@,System.Numerics.Vector3,System.Numerics.Vector3,System.Boolean)">
            <returns>PDF used by <see cref="M:SeeSharp.Shading.Materials.GenericMaterial.Sample(SeeSharp.Geometry.SurfacePoint@,System.Numerics.Vector3,System.Boolean,System.Numerics.Vector2)"/></returns>
        </member>
        <member name="F:SeeSharp.Shading.Materials.GenericMaterial.MaterialParameters">
            <summary>
            The parameters used to create this material
            </summary>
        </member>
        <member name="T:SeeSharp.Shading.Materials.Material">
            <summary>
            Base class for all surface materials
            </summary>
        </member>
        <member name="M:SeeSharp.Shading.Materials.Material.GetRoughness(SeeSharp.Geometry.SurfacePoint@)">
            <summary>
            Computes the surface roughness, a value between 0 and 1.
            0 is perfectly specular, 1 is perfectly diffuse.
            The exact value can differ between materials, as
            this is not a well-defined quantity from a physical point of view.
            </summary>
        </member>
        <member name="M:SeeSharp.Shading.Materials.Material.GetIndexOfRefractionRatio(SeeSharp.Geometry.SurfacePoint@)">
            <summary>
            Computes the ratio of interior and exterior index of refraction. Exterior is defined as the
            hemisphere of the shading normal.
            </summary>
            <param name="hit">The query point in case the material is spatially varying</param>
            <returns>(interior IOR / exterior IOR) at the query point</returns>
        </member>
        <member name="M:SeeSharp.Shading.Materials.Material.GetScatterStrength(SeeSharp.Geometry.SurfacePoint@)">
            <summary>
            Computes the sum of reflectance and transmittance.
            Can be an approximation, with the accuracy depending on the material.
            </summary>
        </member>
        <member name="M:SeeSharp.Shading.Materials.Material.IsTransmissive(SeeSharp.Geometry.SurfacePoint@)">
            <summary>
            False if the material only reflects light (a BRDF), otherwise true (a BSDF)
            </summary>
        </member>
        <member name="M:SeeSharp.Shading.Materials.Material.Evaluate(SeeSharp.Geometry.SurfacePoint@,System.Numerics.Vector3,System.Numerics.Vector3,System.Boolean)">
            <summary>
            Evaluates the BSDF of the material
            </summary>
            <param name="hit">Surface point</param>
            <param name="outDir">Normalized outgoing direction away from the surface (towards camera in a path tracer)</param>
            <param name="inDir">Normalized incoming direction away from the surface (towards light in a path tracer)</param>
            <param name="isOnLightSubpath">True for paths originating from a light source</param>
            <returns>BSDF value</returns>
        </member>
        <member name="M:SeeSharp.Shading.Materials.Material.EvaluateWithCosine(SeeSharp.Geometry.SurfacePoint@,System.Numerics.Vector3,System.Numerics.Vector3,System.Boolean)">
            <summary>
            Computes product of the BSDF and the cosine between the incoming direction and the surface
            shading normal. Usually more efficient / numerically stable than computing individually.
            </summary>
            <param name="hit">Surface point</param>
            <param name="outDir">Normalized outgoing direction away from the surface (towards camera in a path tracer)</param>
            <param name="inDir">Normalized incoming direction away from the surface (towards light in a path tracer)</param>
            <param name="isOnLightSubpath">True for paths originating from a light source</param>
            <returns>BSDF * cosine</returns>
        </member>
        <member name="M:SeeSharp.Shading.Materials.Material.Sample(SeeSharp.Geometry.SurfacePoint@,System.Numerics.Vector3,System.Boolean,System.Numerics.Vector2)">
            <summary>
            Importance samples the product of BSDF and cosine
            </summary>
            <param name="hit">Surface point</param>
            <param name="outDir">Normalized outgoing direction away from the surface (towards camera in a path tracer)</param>
            <param name="isOnLightSubpath">True for paths originating from a light source</param>
            <param name="primarySample">A uniform sample in [0,1]x[0,1] that should be transformed</param>
            <returns>Sampled direction and associated weights</returns>
        </member>
        <member name="M:SeeSharp.Shading.Materials.Material.Pdf(SeeSharp.Geometry.SurfacePoint@,System.Numerics.Vector3,System.Numerics.Vector3,System.Boolean)">
            <returns>The pdf of sampling the incoming direction via <see cref="M:SeeSharp.Shading.Materials.Material.Sample(SeeSharp.Geometry.SurfacePoint@,System.Numerics.Vector3,System.Boolean,System.Numerics.Vector2)"/></returns>
        </member>
        <member name="M:SeeSharp.Shading.Materials.Material.ShouldReflect(SeeSharp.Geometry.SurfacePoint@,System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Tests whether the incoming and outgoing direction are on the same or different sides of the
            actual geometry, based on the actual normal, not the shading normal.
            The directions do not have to be normalized.
            </summary>
            <param name="hit">The surface point</param>
            <param name="outDir">Normalized outgoing direction in world space, away from the surface</param>
            <param name="inDir">Normalized incoming direction in world space, away from the surface</param>
            <returns>True, if they are on the same side, i.e., only reflection should be evaluated.</returns>
        </member>
        <member name="T:SeeSharp.Shading.MicrofacetDistributions.TrowbridgeReitzDistribution">
            <summary>
            GGX microfacet distribution. Heavily based on PBRT v3.
            </summary>
        </member>
        <member name="F:SeeSharp.Shading.MicrofacetDistributions.TrowbridgeReitzDistribution.AlphaX">
            <summary>
            Squared roughness in one direction
            </summary>
        </member>
        <member name="F:SeeSharp.Shading.MicrofacetDistributions.TrowbridgeReitzDistribution.AlphaY">
            <summary>
            Squared roughness in the other direction
            </summary>
        </member>
        <member name="M:SeeSharp.Shading.MicrofacetDistributions.TrowbridgeReitzDistribution.NormalDistribution(System.Numerics.Vector3)">
            <summary>
            Computes the distribution of microfacets with the given normal.
            </summary>
            <param name="normal">The normal vector of the microfacets, in shading space.</param>
            <returns>The fraction of microfacets that are oriented with the given normal.</returns>
        </member>
        <member name="M:SeeSharp.Shading.MicrofacetDistributions.TrowbridgeReitzDistribution.MaskingShadowing(System.Numerics.Vector3)">
            <summary>
            Computes the masking-shadowing function:
            The ratio of visible microfacet area to the total area of all correctly oriented microfacets.
            </summary>
            <param name="normal">
            The normal vector of the microfacets, in shading space.
            </param>
            <returns>The masking shadowing function value ("G" in most papers).</returns>
        </member>
        <member name="M:SeeSharp.Shading.MicrofacetDistributions.TrowbridgeReitzDistribution.Pdf(System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            The Pdf that is used for importance sampling microfacet normals from this distribution.
            This usually importance samples the portion of normals that are in the hemisphere of the outgoing direction.
            </summary>
            <param name="outDir">The outgoing direction in shading space.</param>
            <param name="normal">The normal in shading space.</param>
            <returns>The pdf value.</returns>
        </member>
        <member name="M:SeeSharp.Shading.MicrofacetDistributions.TrowbridgeReitzDistribution.Sample(System.Numerics.Vector3,System.Numerics.Vector2)">
            <summary>
            Warps the given primary sample to follow the pdf computed by <see cref="M:SeeSharp.Shading.MicrofacetDistributions.TrowbridgeReitzDistribution.Pdf(System.Numerics.Vector3,System.Numerics.Vector3)"/>.
            </summary>
            <returns>The direction that corresponds to the given primary sample.</returns>
        </member>
        <member name="M:SeeSharp.Shading.MicrofacetDistributions.TrowbridgeReitzDistribution.MaskingRatio(System.Numerics.Vector3)">
            <summary>
            Computes the ratio of self-masked area to visible area. Used by <see cref="M:SeeSharp.Shading.MicrofacetDistributions.TrowbridgeReitzDistribution.MaskingShadowing(System.Numerics.Vector3)"/>.
            </summary>
            <param name="normal">Normal of the microfacets, in shading space.</param>
            <returns>Ratio of self-masked area to visible area.</returns>
        </member>
        <member name="T:SeeSharp.Shading.ShadingSpace">
            <summary>
            Defines useful functions and operations on directions in shading space.
            This is where all conventions of the shading space are defined.
            </summary>
        </member>
        <member name="M:SeeSharp.Shading.ShadingSpace.ComputeBasisVectors(System.Numerics.Vector3,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Computes an orthogonal tangent and binormal for a given normal vector.
            </summary>
            <param name="normal">The surface normal</param>
            <param name="tangent">A computed tangent</param>
            <param name="binormal">A computed binormal</param>
        </member>
        <member name="M:SeeSharp.Shading.ShadingSpace.WorldToShading(System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Trnasforms the given direction into normalized shading space.
            Assumes that both the direction and the shading normal are normalized.
            </summary>
        </member>
        <member name="M:SeeSharp.Shading.ShadingSpace.ShadingToWorld(System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Trnasforms the given direction from shading space into world space and normalizes it.
            Assumes the shading normal is a valid normal (i.e. normalized).
            </summary>
        </member>
        <member name="M:SeeSharp.Shading.ShadingSpace.CosTheta(System.Numerics.Vector3)">
            <param name="direction">A direction in shading space</param>
            <returns>The cosine of the angle to the normal</returns>
        </member>
        <member name="M:SeeSharp.Shading.ShadingSpace.CosThetaSqr(System.Numerics.Vector3)">
            <returns>Square of the cosine of the angle between the direction and the normal</returns>
        </member>
        <member name="M:SeeSharp.Shading.ShadingSpace.AbsCosTheta(System.Numerics.Vector3)">
            <returns>Absolute value of the cosine of the angle between the direction and the normal</returns>
        </member>
        <member name="M:SeeSharp.Shading.ShadingSpace.Reflect(System.Numerics.Vector3,System.Numerics.Vector3)">
            <returns>The perfect mirror reflection of outDir about the normal</returns>
        </member>
        <member name="M:SeeSharp.Shading.ShadingSpace.Refract(System.Numerics.Vector3,System.Numerics.Vector3,System.Single)">
            <summary>
            Computes the specular refraction of a direction about a normal in shading space.
            </summary>
            <param name="inDir">Direction that is refracted</param>
            <param name="normal">
                The normal about which to refract (can be e.g. a shading or microfacet normal)
            </param>
            <param name="eta">The ratio of IORs</param>
            <returns>Refracted direction, or null in case of total reflection.</returns>
        </member>
        <member name="M:SeeSharp.Shading.ShadingSpace.SameHemisphere(System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Tests if the two directions are in the same hemisphere w.r.t the shading normal.
            </summary>
            <param name="dirA">A direction in shading space</param>
            <param name="dirB">Another direction in shading space</param>
            <returns>True if the sign of the cosine to the normal is the same for both.</returns>
        </member>
    </members>
</doc>
